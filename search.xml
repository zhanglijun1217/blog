<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式 定义一系列的算法，把每一个算法封装起来，并且使它们可以相互替换。这个模式中使得各个算法可以独立于使用它的客户而变化。 策略模式的构成：1.抽象策略角色：策略类，通常由一个接口或者抽象类实现。2.具体策略角色：包装了相关的算法和行为，实现策略接口或继承抽象类。3.环境角色：context，运行时持有一个策略类的引用，最终给客户端调用。对应的uml图片为： 策略模式让算法独立于使用它的客户而独立变化。策略模式重点是封装不同的算法和行为，不同的场景下可以相互替换。策略模式是开闭原则的体现，开闭原则讲的是一个软件实体应该对拓展开放对修改关闭。因为策略模式在加入新的策略时，不会影响其他类的修改，增加了拓展性，也就是对拓展是开放的；对于调用场景来说，只依赖于抽象，而不依赖于具体实现，所以对修改是关闭的。 策略模式的优点和缺点优点：（1）调用策略中的方法在context中，没有和各个策略的实现耦合在一起，各个实现策略的不同子类可以去拓展、修改和切换。（2）避免写很多if else代码，提高了可观性。同时可以结合抽象类（策略类）去使用，Java支持很好。缺点：（1）客户端调用时必须知道所有的策略类，并且感知到要调用哪一种策略实现。（2）一旦抽象，必然会对一些特殊场景难以处理。并且这里去加入了很多的策略实现类，也有Context类的加入，增加了开销。&lt;! –more–&gt; 代码示例比如现在支付方式有四种，这其中每一种方式都对应着不同的最后费用。这样可以应用策略模式。 Strategy.java12345678910111213package design_pattern.strategy_pattern.intf;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;/** * 抽象策略角色Strategy接口 * @author 夸克 * @create 2018/7/23 17:56 */public interface Strategy &#123; // 定义计算recharge的方法 Double calRecharge(Double charge);&#125; 2.StrategyContext.java123456789101112131415161718192021222324package design_pattern.strategy_pattern.context;import design_pattern.strategy_pattern.factory.StrategyFactory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * 策略模式中的环境角色 context * @author 夸克 * @create 2018/7/24 14:57 */public class Context &#123; private Strategy strategy; public Double calRecharge(Double charge, Integer type) &#123; // 利用一个工厂去生成对应的策略 strategy = StrategyFactory.getInstance().creator(ReChargeTypeEnum.from(type)); if (strategy == null) &#123; throw new RuntimeException(&quot;策略生成错误&quot;); &#125; return strategy.calRecharge(charge); &#125;&#125; 3.策略工厂，返回对应的策略12345678910111213141516171819202122232425262728293031323334353637383940package design_pattern.strategy_pattern.factory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;import design_pattern.strategy_pattern.strategy.BusiAcctStrategy;import design_pattern.strategy_pattern.strategy.CardStrategy;import design_pattern.strategy_pattern.strategy.EBankStrategy;import design_pattern.strategy_pattern.strategy.MobileStrategy;import java.util.HashMap;import java.util.Map;/** * 策略工厂 负责Strategy实例的创建 根据传入的type实现创建不同的策略 * @author 夸克 * @create 2018/7/24 15:01 */public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private static Map&lt;ReChargeTypeEnum, Strategy&gt; map = new HashMap&lt;&gt;(); static &#123; map.put(ReChargeTypeEnum.E_BANK, new EBankStrategy()); map.put(ReChargeTypeEnum.BUSI_ACCOUNTS, new BusiAcctStrategy()); map.put(ReChargeTypeEnum.MOBILE, new MobileStrategy()); map.put(ReChargeTypeEnum.CARD_RECHARGE, new CardStrategy()); &#125; /** * getInstance方法进行初始化 * @return */ public static StrategyFactory getInstance() &#123; return factory; &#125; public Strategy creator(ReChargeTypeEnum type) &#123; return map.get(type); &#125;&#125; 四种策略的实现：12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:53 */public class BusiAcctStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.9; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:57 */public class CardStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge + charge * 0.01; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:52 */public class EBankStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.85; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:54 */public class MobileStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge; &#125;&#125; Main.java12345678910111213141516171819202122232425package design_pattern.strategy_pattern.main;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.context.Context;/** * @author 夸克 * @create 2018/7/26 23:30 */public class StrategyMain &#123; public static void main(String[] args) &#123; Context context = new Context(); /** * 计算四种计算方式 */ Double aDouble = context.calRecharge(100D, ReChargeTypeEnum.E_BANK.getValue()); Double bDouble = context.calRecharge(100D, ReChargeTypeEnum.BUSI_ACCOUNTS.getValue()); Double cDouble = context.calRecharge(100D, ReChargeTypeEnum.MOBILE.getValue()); Double dDouble = context.calRecharge(100D, ReChargeTypeEnum.CARD_RECHARGE.getValue()); System.out.println(aDouble + &quot;\t&quot; + bDouble + &quot;\t&quot; + cDouble + &quot;\t&quot; + dDouble); &#125;&#125; github代码已经上传至我的github：https://github.com/zhanglijun1217/java8/tree/master/src/design_pattern/strategy_pattern 引用https://www.jianshu.com/p/71feb016ac05]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[orika转换bean的字段丢失]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2Forika%E8%BD%AC%E6%8D%A2bean%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%A2%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[背景 用orika对象转换工具去转换list的时候，发现只去完整转了list的第一条数据，但是后边的数据都没有将字段全部映射上去。 描述： 1.debug时发现的，源数据list是数据都存在的 2.转完之后的list数据，发现userName、realName等字段是丢失的。 解决经过排查发现是因为在转换注册的字段中，有个type字段没有对应的注册上去。这里就造成了orika这个转换工具丢失了list中记录字段的数据转换。 这里去记录一下这次碰到的小bug，其实也是粗心导致的。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>orika</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[auto md with sublime]]></title>
    <url>%2Fblog%2F2018%2F07%2F22%2Fauto-md-with-sublime%2F</url>
    <content type="text"><![CDATA[利用hexo搭建个人博客 这是利用hexo和github去搭建的个人博客]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[张利君测试博客]]></title>
    <url>%2Fblog%2F2018%2F07%2F16%2F%E5%BC%A0%E5%88%A9%E5%90%9B%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是我的第一篇hexo blog文章。 希望以后可以用这个博客去记录自技术上的一些成长历程]]></content>
  </entry>
</search>
