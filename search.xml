<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring中根据Application获取BEAN的工具类]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2Fspring%E4%B8%AD%E6%A0%B9%E6%8D%AEApplication%E8%8E%B7%E5%8F%96BEAN%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[背景 在最近的开发工作中，用到了策略模式（之前也写过关于策略模式这个设计模式的学习，但是之前那个不是在spring框架中），这时候策略中的context或者factory就要去动态的根据调用的策略类型不同去拿到对应的bean对象，这里去了解了一个通过application context拿取bean的工具类，这里记录一下。 话不多说，直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Component@Slf4jpublic class ApplicationContextBeanUtil implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; /** * 利用aware注入application * @param applicationContext * @throws BeansException */ @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; // 注入application ApplicationContextBeanUtil.applicationContext = applicationContext; &#125; private static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; /** * 通过name获取bean * @param name * @return */ public static Object getBean(String name) &#123; return getApplicationContext().getBean(name); &#125; /** * 通过class获取bean * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(clazz); &#125; /** * 通过name和class获取bean * @param name * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(name, clazz); &#125; /** * 根据clazz类型获取spring容器中的对象 * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBeansOfType(clazz); &#125; /** * 根据注解类从容器中获取对象 * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; Map&lt;String, Object&gt; getBeansOfAnnotation(Class&lt;? extends Annotation&gt; clazz) &#123; return getApplicationContext().getBeansWithAnnotation(clazz); &#125;&#125; 这是通过实现ApplicationContextAware接口去实现注入application的，这里应该注意几点： application应该是静态的。这个Util类应该是在别的类中直接调用获取bean的静态方法，所以注入的applicationContext应该都是该类的静态变量。 要用注解或者在xml文件中将这个Util配置成bean。（这里用的spring boot，就直接配置的扫描）。 在其中提供了一些获取bean的方法。 这里去记录下，方便在之后的工作中遇到了之后去直接使用]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8中list转map方法总结]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2FJava8%E4%B8%ADlist%E8%BD%ACmap%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景 在最近的工作开发之中，慢慢习惯了很多Java8中的Stream的用法，很方便而且也可以并行的去执行这个流，这边去写一下昨天遇到的一个list转map的场景。 list转map在Java8中stream的应用常用方式1.利用Collectors.toMap方法进行转换123public Map&lt;Long, String&gt; getIdNameMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getId, Account::getUsername));&#125; 其中第一个参数就是可以，第二个参数就是value的值。 2.收集对象实体本身 在开发过程中我们也需要有时候对自己的list中的实体按照其中的一个字段进行分组（比如 id -&gt;List），这时候要设置map的value值是实体本身。123public Map&lt;Long, Account&gt; getIdAccountMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getId, account -&gt; account));&#125; account -&gt; account是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法 Function.identity()，这个方法返回自身对象，更加简洁 重复key的情况。 在list转为map时，作为key的值有可能重复，这时候流的处理会抛出个异常：Java.lang.IllegalStateException:Duplicate key。这时候就要在toMap方法中指定当key冲突时key的选择。(这里是选择第二个key覆盖第一个key)123public Map&lt;String, Account&gt; getNameAccountMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getUsername, Function.identity(), (key1, key2) -&gt; key2));&#125; 用groupingBy 或者 partitioningBy进行分组 根据一个字段或者属性分组也可以直接用groupingBy方法，很方便。 12345678Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());&#125; partitioningBy可以理解为特殊的groupingBy，key值为true和false，当然此时方法中的参数为一个判断语句（用于判断的函数式接口） 12345Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println(&quot;Children number: &quot; + children.get(true).size());System.out.println(&quot;Adult number: &quot; + children.get(false).size()); 关于stream使用的好文推荐： 这里去看了ibm的一篇关于stream的文章，get到了不少stream还没遇到过的用法。老铁们可以去学习一下。[https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/ ]]]></content>
      <categories>
        <category>Java语法</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——CopyOnWrite容器]]></title>
    <url>%2Fblog%2F2018%2F08%2F04%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94CopyOnWrite%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。 什么是CopyOnWrite容器从字面意思上看是写时复制的容器。通俗理解就是我们往一个容器中添加元素时，不直接往容器中添加，而是先将容器copy，复制出一个新的容器，然后新的容器里添加元素，添加完新的元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，但不需要加锁，因为当前在读的容器中不会添加新的元素，运用一种读写分离容器的思想。 copyOnWriteArrayList实现原理来看几个方法（1）add (E e)这里是要加锁的，因为在add的时候是要Arrays.copyOf出一个容器副本的，如果多线程访问会造成copy多个容器副本出来。可以看到是在copy完成添加元素之后去将引用指向这个新的数组。1234567891011121314151617181920/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; （2）get(int index)读的时候并没有加锁，如果读的时候有线程同时去添加元素，还是会读到之前的旧的容器，所以并不用加速，但要求对读的数据一致性没那么高。123456789/** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; return get(getArray(), index);&#125; 应用场景 copyOnWrite并发容器用于读多写少的并发场景。比如白名单、黑名单、商品类目等。比如有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单每晚会更新一次。当用户搜索时，会检查关键字在不在黑名单中，如果在，则提示不能搜索。 另外迭代操作远远大于修改操作时，才应该使用“写入时复制”容器。这个准则很好的描述了许多事件通知系统：在分发通知时需要迭代已注册监听器链表，并调用每个监听器，在大多数情况下，注册和注销事件监听器的操作远少于接受事件通知的操作。 copyOnWriteArrayList用于替代同步list，在某些情况下它提供了更好的并发性能，并且能在迭代期间不需要对容器进行加锁或者复制。 实现一个copyOnWriteMap容器 简单根据“写入时复制”的思想实现一个map容器，并做简单测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package collection;import java.util.AbstractMap;import java.util.HashMap;import java.util.Map;import java.util.Set;/** * 简单根据CopyOnWrite容器的思想去实现一个map 只实现了get put putAll方法 且一些临界异常条件没有去处理 * * @author 夸克 * @create 2018/7/8 15:58 */public class CopyOnWriteMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable &#123; private volatile Map&lt;K, V&gt; internalMap; public CopyOnWriteMap() &#123; internalMap = new HashMap&lt;&gt;(); &#125; /** * 此方法未实现 */ @Override public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123; return null; &#125; @Override public V get(Object key) &#123; // 读时不加锁 return internalMap.get(key); &#125; @Override public V put(K key, V value) &#123; // 写时复制加锁 synchronized (this) &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap); V val = newMap.put(key, value); internalMap = newMap; return val; &#125; &#125; @Override public void putAll(Map&lt;? extends K, ? extends V&gt; data) &#123; synchronized (this) &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;&gt;(internalMap); newMap.putAll(data); internalMap = newMap; &#125; &#125; public static void main(String[] args) &#123; CopyOnWriteMap&lt;Integer, Integer&gt; copyOnWriteMap = new CopyOnWriteMap(); // 初始化数据 Map&lt;Integer, Integer&gt; map = new HashMap(); for (int i = 0; i &lt; 10; i++) &#123; map.put(i, i); &#125; // 读五次线程 for (int i = 0; i &lt; 5; i++) &#123; Thread read = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 方便写线程写入数据 如果不加sleep 是读不到数据的，因为是在新复制的容器中写。 // 测试copyOnWrite思想 Thread.sleep(500); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(copyOnWriteMap.get(5)); &#125; &#125;); read.start(); &#125; // 写线程 Thread write = new Thread(new Runnable() &#123; @Override public void run() &#123; map.forEach((k, v) -&gt; &#123; copyOnWriteMap.put(k, v); &#125;); &#125; &#125;); write.start(); &#125;&#125; 代码地址https://github.com/zhanglijun1217/juc 缺点 显然，每次修改容器的时候都会复制底层数组，这回造成一定的内存开销，特别是当容器的规模很大的时候，可能有将内存撑爆的可能性存在。这时候可能要考虑别的容器。另外上边也提到了这种复制一份新的容器延迟的做法会有数据一致性的问题，如果你对写入的数据读出来实时性很高，那么久不要去选择copyOnWrite容器。 其他文章 copyOnWriteArrayList于同步集合工具容器性能比较：性能比较 简单使用：简单使用 引用说明 1.https://www.cnblogs.com/dolphin0520/p/3938914.html2.《java并发编程实战》]]></content>
  </entry>
  <entry>
    <title><![CDATA[并发编程——线程基础（一）]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[线程是Java学习过程中比较难理解的一part，所以要好好打下基础，之后也会对juc包等其他并发编知识去做一个具体的原理性的学习。 一些概念一、并发与并行 并发：同一个时间间隔内做很多件事情；并行：同一个时刻同时做多件事情。 其实对于这句话可以这样理解：并发是两个任务可以在重叠的时间段内启动、运行和完成。并行是任务在同一时间运行，例如，在多核处理器上，并发是独立执行过程的组合，而并行是同时执行的。并发更像是操作系统用线程模型抽象之后站在线程的角度上看到的任务的”同时“执行。 二、临界区 表示一种公有区域或者公有数据，但是每一次只有一个线程使用，其他线程想使用必须等待。进程在访问资源的时候必须经过这些步骤：【进程】–&gt;【进入区（申请资源）】–&gt;【临界区】–&gt;【退出区（释放资源）】 在进入区中资源如果被占用访问，其他进入阻塞队列等待。 阻塞：一个线程占用了临界区资源，其他需要这个资源的线程在临界区中等待，导致这些线程挂起。 非阻塞：其他线程可以同时进入临界区，但保证公有数据不被改坏。 三、锁 死锁（DeadLock）:线程之间互相等待释放资源 饥饿锁（strarvation）:某一个线程或多个线程无法获取资源，导致一直无法执行 活锁（liveLock）:可以想象为电梯遇到人，同时都往一个方向去给对方让出资源，是个动态的问题 四、并发级别 阻塞状态级别 非阻塞状态级别（这里面还分为三种）(1) 无障碍。一种最弱的非阻塞调度，自由进出临界区。无竞争时要求有限步骤内完成操作；无竞争时直接进行回滚数据。(2) 无锁。保证只有一个线程可以胜出访问临界资源。比如乐观锁（CAS）(3) 无等待的，并发中最高级别，是无锁的，要求所有的线程都在有限步内完成，并且无饥饿的。比如：读线程和写线程，所有线程都是无等待的。比如CopyOnWriteArrayList写时写副本数据，读时共享读，线程之间是无等待的。 五、并行的两个定律 加速比：优化前系统耗时/优化后系统耗时。 说明增加CPU个数不一定增加加速比。 古斯塔夫森定律：只要有足够的并行化，那么加速比和CPU个数成正比 六、线程相关知识线程和进程 进程是分配资源的基本单位，线程是CPU调度的基本单位。进程之间的资源是互相独立不可共享的，但是线程之间是可以共享父线程或者进程的资源的。进程之间切换要比线程之间切换消耗资源代价多很多。 线程的状态 新建状态（NEW）：新创建了一个线程对象 可运行状态（RUNNABLE）：线程对象创建之后，其他线程（比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。 运行（running）：可运行状态的线程获得了cpu时间片，执行程序代码。 阻塞（block）：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行（runnable）状态，才有机会再次获得cpu timeslice转到运行（running）状态。其中阻塞的状态分三种：（1）等待阻塞：运行（running）的线程执行o.wait()方法，JVM会把线程放入到等待队列（waitting queue）中。（2）同步阻塞：运行（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池（lock pool）中。（3）其他阻塞：运行（running）的线程执行Thread.Sleep(long ms)或者join方法，或者发出了IO请求，JVM会把该线程置为阻塞状态。当sleep状态超时、join()等待线程终止或者超时、或者IO处理完毕之后，线程重新转入可运行（runnable）状态。 死亡（dead）：线程run()、main()方法执行结束，或者因一场退出了run()方法，则该线程结束生命周期，死亡的线程不可再次复生。 线程状态扭转的图：可以看到：（1）当调用new Threa()方法之后，线程就会处于新建状态。（2）调用start()方法之后，线程会进入runnable状态，当操作系统选中之后给当前线程分配了时间片线程进入running状态。（3）当run()方法、main()方法结束或者发生异常，线程会进入dead状态。（4）当因为synchronize或者lock同步方法，线程没有获取到锁标识就会进入到锁池（lock pool）中等待；同样当调用o.wait()方法之后线程会进入等待队列中，这时会释放锁或者monitor，直到被其他线程的notify()方法或者notifyAll()方法唤醒。（5）当调用Thread.yield()方法之后，会使线程从running状态转换到runnable状态再去和其他线程一起去竞争时间片资源，所以会出现调用yield()方法之后又重新竞争到了资源变成running状态。（6）当调用了sleep()/join()方法之后，线程并不会释放锁或者monitor，而当sleep时间到了或者调用join()方法的线程执行完毕之后会继续进入running状态。 注意其中线程的一些方法经常在面试中问到的问题： 1.sleep方法和wait方法的区别 （1）sleep是Thread类的方法，wait是Object类的方法（2）调用sleep方法不会释放锁，wait方法会使线程释放当前的锁。（3）wait方法必须别的线程执行notify/notifyAll()方法才能重新获取CPU执行时间。 2.join()方法的本质 join方法是把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如main线程中调用t.join()时候，main线程会获得线程对象t的锁，调用对象的wait方法(等待时间)，直到该对象唤醒main线程，所以意味着main线程调用t.join()时，必须能够拿到线程t对象的锁。注意join()方法也是要捕捉异常的，关于join()方法的比较好的一篇文章：http://uule.iteye.com/blog/1101994 3.yield()方法 yield()方法与sleep()方法类似，只是不能由用户指定暂停多长时间，并且yield()方法只能让同优先级的线程有执行的机会，yield()方法不会释放对象上的锁。 4.wait()和notify()、notifyAll() 这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized中执行使用。synchronized关键字用于保护共享数据，阻止其他线程对共享数据的存取，可以用这三个方法去灵活控制。wait()方法使当前的线程暂停执行并释放对象锁标识，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中，只有锁标志等待池中线程能获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。notifyAll()方法则从对象等待池中移走所有等待那个对象的线程并放入锁标志等待池中。 wait()、notify()方法是Object类的方法，因为他们必须要标识它们操作线程的锁，而锁对象可能是任何对象，所有这里这两个方法是Object类的方法。 线程创建几种方式继承Thread类 可以继承Thread实现其中的run()方法12345678910111213141516171819202122232425262728293031323334353637public class NewThread2 extends Thread &#123; public NewThread2(String name) &#123; super(name); &#125; @Override public void run() &#123; while (!interrupted()) &#123;// 这里的循环是当不被中断的时候 才执行 System.out.println(getName() + &quot; 线程运行&quot;); &#125; &#125; public static void main(String[] args) &#123; NewThread2 t1 = new NewThread2(&quot;first thread&quot;); NewThread2 t2 = new NewThread2(&quot;second thread&quot;); t1.setDaemon(true);// 后台（守护）线程会随着主线程结束也结束 t2.setDaemon(true); t1.start(); t2.start(); // 中断不用stop()方法 已经过时 t1.interrupt(); t2.interrupt();// try &#123; // 让主线程sleep两秒 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实现Runnable接口其实看到Thread类也是实现了Runnable接口的。1234567891011121314151617181920212223242526272829303132333435363738394041424344package newthread;/** * created by zlj on 2018/5/31 * Runnable接口 创建线程 */public class NewThread implements Runnable &#123; @Override public synchronized void run() &#123; while (true) &#123; try &#123; // Thread.sleep(1000);// 调用超时等待使得线程进入阻塞状态 到达时间后线程到达就绪状态 wait();// 线程通讯必须在同步代码块中 否则会报错IllegalMonitorStateException &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;自定义线程执行...&quot;); &#125; &#125; public static void main(String[] args) &#123; NewThread newThread = new NewThread(); // 线程初始化 Thread thread = new Thread(newThread);// 构造函数是runnable接口参数 thread.start();// 调用start方法使得线程进入就绪状态 while (true) &#123; synchronized (newThread) &#123;// 这里同步代码块中监视的是同步的对象 对应上边wait方法获取的是this对象 System.out.println(&quot;主线程执行...&quot;);// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; newThread.notifyAll();// notify方法必须在同步监视器中 否则会报错 &#125; &#125; &#125;&#125; 实现Callable接口（线程可以有返回值和抛出异常）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package newthread;import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;/** * created by zlj on 2018/5/31 * 带有返回值 和 抛出异常 的线程创建 */public class NewThread4 implements Callable&lt;Integer&gt; &#123; // 实现call方法 // callable接口 和 runnable接口 比较：（1）callable接口可以传入泛型有返回值 （2）可以抛出异常 @Override public Integer call() throws Exception &#123; System.out.println(&quot;正在紧张的计算&quot;); // sleep 模拟计算过程 Thread.sleep(3000); return 1; &#125; public static void main(String[] args) &#123; NewThread4 t = new NewThread4(); /* * 对线程任务的封装 */ // 主线程可以先去做点别的 System.out.println(&quot;先去做点别的&quot;); // 首先用FutureTask&lt;T&gt; 对 call 封装成任务 FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(t); // 再根据构造函数去封装成Thread对象 传入FutureTask类型的task Thread thread = new Thread(task); thread.start(); // 拿到线程的结果 try &#123; System.out.println(&quot;计算的结果是&quot; + task.get()); // 这里注意TaskFuture的get()方法是等上边线程结束之后去进行计算结果的。也是一个闭锁操作 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程池实现1234567891011121314151617181920212223242526272829303132package newthread;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * created by zlj on 2018/5/31 * 线程池创建线程 */public class NewThread6 &#123; public static void main(String[] args) &#123; // 创建十个定长的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); // 提交一百个 线程执行的任务 for (int i=0; i&lt;100; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;); &#125; // 线程池的停止销毁 否则程序一直会运行 threadPool.shutdown(); // 注意shutdownNow方法和shutdown方法的区别 threadPool.shutdownNow(); &#125;&#125; Executors中提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。（1）public static ExecutorService newFixedThreadpPool(int nThreads) // 创建国定数目线程的线程池。（2）public static ExecutorService newCachedThreadPool() // 创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有60秒钟未被使用的线程。（3）public static ExecutorService newSingleThreadExecutor（） // 创建一个单线程化的Executor（4）public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) // 创建一个支持定时及周期性的任务执行线程池，多数情况可以用来替代Timer类。但是其实在阿里的代码检查工具中，是不建议去使用这个工具类去调用线程池的，建议去手动的写自定义的线程池。 线程中的其他常见方法 方法 说明 setPriority(int priority) 设置线程的优先级 setDaemon(boolean on) 设置是否为后台线程 interrupt() 中断线程 isAlive() 测试线程是否处于活动状态 守护线程和用户线程的区别：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法允许完毕之后，守护线程也会随着消亡，而用户线程则不依赖会一直运行到完毕为止，在JVM中像垃圾回收线程就是守护线程。但是要注意，设置守护线程要在thread.start()方法之前，否则会报IllegalThreadStateException异常。不应该所有的线程都可以分配给Deamon线程来进行服务，比如读写操作或计算逻辑，因为在Deamon Thread没来得及进行操作时，虚拟机可能已经退出了。 停止线程的方法 使用退出标志，使线程正常退出。 使用stop方法终止线程（已过时不推荐） while判断 + interrupt方法终止线程。其中interrupt方法不会终止正在运行的线程，所以要加入一个判断去完成线程的优雅退出。 一些面试题 线程和进程有什么区别？答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。 Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 线程的sleep()方法和yield()方法有什么区别？答：① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 请说出与线程同步以及线程调度相关的方法。wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 先写到这关于线程的知识总结还有很多，后边关于并发编程还要更深入的理解，这里先上一张知识总结图吧。]]></content>
      <categories>
        <category>-并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式 定义一系列的算法，把每一个算法封装起来，并且使它们可以相互替换。这个模式中使得各个算法可以独立于使用它的客户而变化。 策略模式的构成：1.抽象策略角色：策略类，通常由一个接口或者抽象类实现。2.具体策略角色：包装了相关的算法和行为，实现策略接口或继承抽象类。3.环境角色：context，运行时持有一个策略类的引用，最终给客户端调用。对应的uml图片为： 策略模式让算法独立于使用它的客户而独立变化。策略模式重点是封装不同的算法和行为，不同的场景下可以相互替换。策略模式是开闭原则的体现，开闭原则讲的是一个软件实体应该对拓展开放对修改关闭。因为策略模式在加入新的策略时，不会影响其他类的修改，增加了拓展性，也就是对拓展是开放的；对于调用场景来说，只依赖于抽象，而不依赖于具体实现，所以对修改是关闭的。 策略模式的优点和缺点优点：（1）调用策略中的方法在context中，没有和各个策略的实现耦合在一起，各个实现策略的不同子类可以去拓展、修改和切换。（2）避免写很多if else代码，提高了可观性。同时可以结合抽象类（策略类）去使用，Java支持很好。缺点：（1）客户端调用时必须知道所有的策略类，并且感知到要调用哪一种策略实现。（2）一旦抽象，必然会对一些特殊场景难以处理。并且这里去加入了很多的策略实现类，也有Context类的加入，增加了开销。 代码示例比如现在支付方式有四种，这其中每一种方式都对应着不同的最后费用。这样可以应用策略模式。 Strategy.java12345678910111213package design_pattern.strategy_pattern.intf;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;/** * 抽象策略角色Strategy接口 * @author 夸克 * @create 2018/7/23 17:56 */public interface Strategy &#123; // 定义计算recharge的方法 Double calRecharge(Double charge);&#125; 2.StrategyContext.java123456789101112131415161718192021222324package design_pattern.strategy_pattern.context;import design_pattern.strategy_pattern.factory.StrategyFactory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * 策略模式中的环境角色 context * @author 夸克 * @create 2018/7/24 14:57 */public class Context &#123; private Strategy strategy; public Double calRecharge(Double charge, Integer type) &#123; // 利用一个工厂去生成对应的策略 strategy = StrategyFactory.getInstance().creator(ReChargeTypeEnum.from(type)); if (strategy == null) &#123; throw new RuntimeException(&quot;策略生成错误&quot;); &#125; return strategy.calRecharge(charge); &#125;&#125; 3.策略工厂，返回对应的策略12345678910111213141516171819202122232425262728293031323334353637383940package design_pattern.strategy_pattern.factory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;import design_pattern.strategy_pattern.strategy.BusiAcctStrategy;import design_pattern.strategy_pattern.strategy.CardStrategy;import design_pattern.strategy_pattern.strategy.EBankStrategy;import design_pattern.strategy_pattern.strategy.MobileStrategy;import java.util.HashMap;import java.util.Map;/** * 策略工厂 负责Strategy实例的创建 根据传入的type实现创建不同的策略 * @author 夸克 * @create 2018/7/24 15:01 */public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private static Map&lt;ReChargeTypeEnum, Strategy&gt; map = new HashMap&lt;&gt;(); static &#123; map.put(ReChargeTypeEnum.E_BANK, new EBankStrategy()); map.put(ReChargeTypeEnum.BUSI_ACCOUNTS, new BusiAcctStrategy()); map.put(ReChargeTypeEnum.MOBILE, new MobileStrategy()); map.put(ReChargeTypeEnum.CARD_RECHARGE, new CardStrategy()); &#125; /** * getInstance方法进行初始化 * @return */ public static StrategyFactory getInstance() &#123; return factory; &#125; public Strategy creator(ReChargeTypeEnum type) &#123; return map.get(type); &#125;&#125; 四种策略的实现：12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:53 */public class BusiAcctStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.9; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:57 */public class CardStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge + charge * 0.01; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:52 */public class EBankStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.85; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:54 */public class MobileStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge; &#125;&#125; Main.java12345678910111213141516171819202122232425package design_pattern.strategy_pattern.main;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.context.Context;/** * @author 夸克 * @create 2018/7/26 23:30 */public class StrategyMain &#123; public static void main(String[] args) &#123; Context context = new Context(); /** * 计算四种计算方式 */ Double aDouble = context.calRecharge(100D, ReChargeTypeEnum.E_BANK.getValue()); Double bDouble = context.calRecharge(100D, ReChargeTypeEnum.BUSI_ACCOUNTS.getValue()); Double cDouble = context.calRecharge(100D, ReChargeTypeEnum.MOBILE.getValue()); Double dDouble = context.calRecharge(100D, ReChargeTypeEnum.CARD_RECHARGE.getValue()); System.out.println(aDouble + &quot;\t&quot; + bDouble + &quot;\t&quot; + cDouble + &quot;\t&quot; + dDouble); &#125;&#125; github代码已经上传至我的github：https://github.com/zhanglijun1217/java8/tree/master/src/design_pattern/strategy_pattern 引用https://www.jianshu.com/p/71feb016ac05]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[orika转换bean的字段丢失]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2Forika%E8%BD%AC%E6%8D%A2bean%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%A2%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[背景 用orika对象转换工具去转换list的时候，发现只去完整转了list的第一条数据，但是后边的数据都没有将字段全部映射上去。 描述： 1.debug时发现的，源数据list是数据都存在的 2.转完之后的list数据，发现userName、realName等字段是丢失的。 解决经过排查发现是因为在转换注册的字段中，有个type字段没有对应的注册上去。这里就造成了orika这个转换工具丢失了list中记录字段的数据转换。 这里去记录一下这次碰到的小bug，其实也是粗心导致的。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>orika</tag>
        <tag>bug</tag>
      </tags>
  </entry>
</search>
