<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[并发编程——线程基础（一）]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[线程是Java学习过程中比较难理解的一part，所以要好好打下基础，之后也会对juc包等其他并发编知识去做一个具体的原理性的学习。 一些概念并发与并行 并发：同一个时间间隔内做很多件事情；并行：同一个时刻同时做多件事情。 其实对于这句话可以这样理解：并发是两个任务可以在重叠的时间段内启动、运行和完成。并行是任务在同一时间运行，例如，在多核处理器上，并发是独立执行过程的组合，而并行是同时执行的。并发更像是操作系统用线程模型抽象之后站在线程的角度上看到的任务的”同时“执行。 临界区 表示一种公有区域或者公有数据，但是每一次只有一个线程使用，其他线程想使用必须等待。进程在访问资源的时候必须经过这些步骤：【进程】–&gt;【进入区（申请资源）】–&gt;【临界区】–&gt;【退出区（释放资源）】 在进入区中资源如果被占用访问，其他进入阻塞队列等待。 阻塞：一个线程占用了临界区资源，其他需要这个资源的线程在临界区中等待，导致这些线程挂起。 非阻塞：其他线程可以同时进入临界区，但保证公有数据不被改坏。锁 死锁（DeadLock）:线程之间互相等待释放资源 饥饿锁（strarvation）:某一个线程或多个线程无法获取资源，导致一直无法执行 活锁（liveLock）:可以想象为电梯遇到人，同时都往一个方向去给对方让出资源，是个动态的问题并发级别 阻塞状态级别 非阻塞状态级别（这里面还分为三种）无障碍 一种最弱的非阻塞调度，自由进出临界区。无竞争时要求有限步骤内完成操作；无竞争时直接进行回滚数据。无锁 无障碍的，保证只有一个线程可以胜出访问临界资源。比如乐观锁（CAS） 无等待的，并发中最高级别，是无锁的，要求所有的线程都在有限步内完成，并且无饥饿的。比如：读线程和写线程，所有线程都是无等待的。比如CopyOnWriteArrayList写时写副本数据，读时共享读，线程之间是无等待的。##并行的两个定律 加速比：优化前系统耗时/优化后系统耗时。 说明增加CPU个数不一定增加加速比。 古斯塔夫森定律：只要有足够的并行化，那么加速比和CPU个数成正比线程相关知识线程和进程 进程是分配资源的基本单位，线程是CPU调度的基本单位。进程之间的资源是互相独立不可共享的，但是线程之间是可以共享父线程或者进程的资源的。进程之间切换要比线程之间切换消耗资源代价多很多。线程的状态 新建状态（NEW）：新创建了一个线程对象 可运行状态（RUNNABLE）：线程对象创建之后，其他线程（比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。 运行（running）：可运行状态的线程获得了cpu时间片，执行程序代码。 阻塞（block）：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行（runnable）状态，才有机会再次获得cpu timeslice转到运行（running）状态。其中阻塞的状态分三种：（1）等待阻塞：运行（running）的线程执行o.wait()方法，JVM会把线程放入到等待队列（waitting queue）中。（2）同步阻塞：运行（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池（lock pool）中。（3）其他阻塞：运行（running）的线程执行Thread.Sleep(long ms)或者join方法，或者发出了IO请求，JVM会把该线程置为阻塞状态。当sleep状态超时、join()等待线程终止或者超时、或者IO处理完毕之后，线程重新转入可运行（runnable）状态。 死亡（dead）：线程run()、main()方法执行结束，或者因一场退出了run()方法，则该线程结束生命周期，死亡的线程不可再次复生。 线程状态扭转的图：可以看到：（1）当调用new Threa()方法之后，线程就会处于新建状态。（2）调用start()方法之后，线程会进入runnable状态，当操作系统选中之后给当前线程分配了时间片线程进入running状态。（3）当run()方法、main()方法结束或者发生异常，线程会进入dead状态。（4）当因为synchronize或者lock同步方法，线程没有获取到锁标识就会进入到锁池（lock pool）中等待；同样当调用o.wait()方法之后线程会进入等待队列中，这时会释放锁或者monitor，直到被其他线程的notify()方法或者notifyAll()方法唤醒。（5）当调用Thread.yield()方法之后，会使线程从running状态转换到runnable状态再去和其他线程一起去竞争时间片资源，所以会出现调用yield()方法之后又重新竞争到了资源变成running状态。（6）当调用了sleep()/join()方法之后，线程并不会释放锁或者monitor，而当sleep时间到了或者调用join()方法的线程执行完毕之后会继续进入running状态。 注意其中线程的一些方法经常在面试中问到的问题：1.sleep方法和wait方法的区别（1）sleep是Thread类的方法，wait是Object类的方法（2）调用sleep方法不会释放锁，wait方法会使线程释放当前的锁。（3）wait方法必须别的线程执行notify/notifyAll()方法才能重新获取CPU执行时间。2.join()方法的本质join方法是把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如main线程中调用t.join()时候，main线程会获得线程对象t的锁，调用对象的wait方法(等待时间)，直到该对象唤醒main线程，所以意味着main线程调用t.join()时，必须能够拿到线程t对象的锁。注意join()方法也是要捕捉异常的，关于join()方法的比较好的一篇文章：http://uule.iteye.com/blog/11019943.yield()方法 yield()方法与sleep()方法类似，只是不能由用户指定暂停多长时间，并且yield()方法只能让同优先级的线程有执行的机会，yield()方法不会释放对象上的锁。4.wait()和notify()、notifyAll() 这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized中执行使用。synchronized关键字用于保护共享数据，阻止其他线程对共享数据的存取，可以用这三个方法去灵活控制。wait()方法使当前的线程暂停执行并释放对象锁标识，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中，只有锁标志等待池中线程能获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。notifyAll()方法则从对象等待池中移走所有等待那个对象的线程并放入锁标志等待池中。 wait()、notify()方法是Object类的方法，因为他们必须要标识它们操作线程的锁，而锁对象可能是任何对象，所有这里这两个方法是Object类的方法。线程创建几种方式继承Thread类 可以继承Thread实现其中的run()方法 实现Runnable接口实现Callable接口（线程可以有返回值和抛出异常）线程池实现线程中的其他常见方法]]></content>
      <categories>
        <category>-并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式 定义一系列的算法，把每一个算法封装起来，并且使它们可以相互替换。这个模式中使得各个算法可以独立于使用它的客户而变化。 策略模式的构成：1.抽象策略角色：策略类，通常由一个接口或者抽象类实现。2.具体策略角色：包装了相关的算法和行为，实现策略接口或继承抽象类。3.环境角色：context，运行时持有一个策略类的引用，最终给客户端调用。对应的uml图片为： 策略模式让算法独立于使用它的客户而独立变化。策略模式重点是封装不同的算法和行为，不同的场景下可以相互替换。策略模式是开闭原则的体现，开闭原则讲的是一个软件实体应该对拓展开放对修改关闭。因为策略模式在加入新的策略时，不会影响其他类的修改，增加了拓展性，也就是对拓展是开放的；对于调用场景来说，只依赖于抽象，而不依赖于具体实现，所以对修改是关闭的。 策略模式的优点和缺点优点：（1）调用策略中的方法在context中，没有和各个策略的实现耦合在一起，各个实现策略的不同子类可以去拓展、修改和切换。（2）避免写很多if else代码，提高了可观性。同时可以结合抽象类（策略类）去使用，Java支持很好。缺点：（1）客户端调用时必须知道所有的策略类，并且感知到要调用哪一种策略实现。（2）一旦抽象，必然会对一些特殊场景难以处理。并且这里去加入了很多的策略实现类，也有Context类的加入，增加了开销。 代码示例比如现在支付方式有四种，这其中每一种方式都对应着不同的最后费用。这样可以应用策略模式。 Strategy.java12345678910111213package design_pattern.strategy_pattern.intf;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;/** * 抽象策略角色Strategy接口 * @author 夸克 * @create 2018/7/23 17:56 */public interface Strategy &#123; // 定义计算recharge的方法 Double calRecharge(Double charge);&#125; 2.StrategyContext.java123456789101112131415161718192021222324package design_pattern.strategy_pattern.context;import design_pattern.strategy_pattern.factory.StrategyFactory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * 策略模式中的环境角色 context * @author 夸克 * @create 2018/7/24 14:57 */public class Context &#123; private Strategy strategy; public Double calRecharge(Double charge, Integer type) &#123; // 利用一个工厂去生成对应的策略 strategy = StrategyFactory.getInstance().creator(ReChargeTypeEnum.from(type)); if (strategy == null) &#123; throw new RuntimeException(&quot;策略生成错误&quot;); &#125; return strategy.calRecharge(charge); &#125;&#125; 3.策略工厂，返回对应的策略12345678910111213141516171819202122232425262728293031323334353637383940package design_pattern.strategy_pattern.factory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;import design_pattern.strategy_pattern.strategy.BusiAcctStrategy;import design_pattern.strategy_pattern.strategy.CardStrategy;import design_pattern.strategy_pattern.strategy.EBankStrategy;import design_pattern.strategy_pattern.strategy.MobileStrategy;import java.util.HashMap;import java.util.Map;/** * 策略工厂 负责Strategy实例的创建 根据传入的type实现创建不同的策略 * @author 夸克 * @create 2018/7/24 15:01 */public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private static Map&lt;ReChargeTypeEnum, Strategy&gt; map = new HashMap&lt;&gt;(); static &#123; map.put(ReChargeTypeEnum.E_BANK, new EBankStrategy()); map.put(ReChargeTypeEnum.BUSI_ACCOUNTS, new BusiAcctStrategy()); map.put(ReChargeTypeEnum.MOBILE, new MobileStrategy()); map.put(ReChargeTypeEnum.CARD_RECHARGE, new CardStrategy()); &#125; /** * getInstance方法进行初始化 * @return */ public static StrategyFactory getInstance() &#123; return factory; &#125; public Strategy creator(ReChargeTypeEnum type) &#123; return map.get(type); &#125;&#125; 四种策略的实现：12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:53 */public class BusiAcctStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.9; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:57 */public class CardStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge + charge * 0.01; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:52 */public class EBankStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.85; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:54 */public class MobileStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge; &#125;&#125; Main.java12345678910111213141516171819202122232425package design_pattern.strategy_pattern.main;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.context.Context;/** * @author 夸克 * @create 2018/7/26 23:30 */public class StrategyMain &#123; public static void main(String[] args) &#123; Context context = new Context(); /** * 计算四种计算方式 */ Double aDouble = context.calRecharge(100D, ReChargeTypeEnum.E_BANK.getValue()); Double bDouble = context.calRecharge(100D, ReChargeTypeEnum.BUSI_ACCOUNTS.getValue()); Double cDouble = context.calRecharge(100D, ReChargeTypeEnum.MOBILE.getValue()); Double dDouble = context.calRecharge(100D, ReChargeTypeEnum.CARD_RECHARGE.getValue()); System.out.println(aDouble + &quot;\t&quot; + bDouble + &quot;\t&quot; + cDouble + &quot;\t&quot; + dDouble); &#125;&#125; github代码已经上传至我的github：https://github.com/zhanglijun1217/java8/tree/master/src/design_pattern/strategy_pattern 引用https://www.jianshu.com/p/71feb016ac05]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[orika转换bean的字段丢失]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2Forika%E8%BD%AC%E6%8D%A2bean%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%A2%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[背景 用orika对象转换工具去转换list的时候，发现只去完整转了list的第一条数据，但是后边的数据都没有将字段全部映射上去。 描述： 1.debug时发现的，源数据list是数据都存在的 2.转完之后的list数据，发现userName、realName等字段是丢失的。 解决经过排查发现是因为在转换注册的字段中，有个type字段没有对应的注册上去。这里就造成了orika这个转换工具丢失了list中记录字段的数据转换。 这里去记录一下这次碰到的小bug，其实也是粗心导致的。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>orika</tag>
        <tag>bug</tag>
      </tags>
  </entry>
</search>
