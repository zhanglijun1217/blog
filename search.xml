<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java8中的LocalDateTime]]></title>
    <url>%2Fblog%2F2018%2F11%2F11%2Fjava8%E4%B8%AD%E7%9A%84LocalDateTime%2F</url>
    <content type="text"><![CDATA[背景最近在项目中遇到了一些时间进行转化的小需求，比如一个时间添加多少天之后，两个时间的比较之类的。这里要去了解一下java8中的新增的时间API–LocalDateTime。 参考博客： 一些用法系统时间12345678910111213141516171819// now方法获取系统时间LocalDate date = LocalDate.now();// getMonth：英文 getMonthValue : 数字System.out.println(date.getYear() + "/" + date.getMonthValue() + "/" + date.getDayOfMonth());LocalTime time = LocalTime.now();System.out.println(time.getHour() + ":" + time.getMinute() + ":" + time.getSecond());// 没有提供 getMiles()方法 可以这样获取mileSystem.out.println(time.get(ChronoField.MILLI_OF_SECOND));// 日期和时间LocalDateTime dateTime = LocalDateTime.now();System.out.println(dateTime.getYear() + "/" + dateTime.getMonthValue() + "/" + dateTime.getDayOfMonth() + " " + dateTime.getHour() + ":" + dateTime.getMinute() + ":" + dateTime.getSecond());// 时区 获取时间戳Clock clock = Clock.systemDefaultZone();System.out.println(clock.millis()); 特定日期12345678910111213141516171819202122// of方法获取特定日期LocalDate myDate = LocalDate.of(2018, 11, 6);System.out.println(myDate.getYear() + "/" + myDate.getMonthValue() + "/" + myDate.getDayOfMonth());// 获取特定日期对应的属性LocalDate independenceDay = LocalDate.of(2018, Month.JUNE, 4);// 获取周几System.out.println(independenceDay.getDayOfWeek());// 构造LocalTimeLocalTime myTime = LocalTime.of(10, 30, 45);System.out.println(myTime.getHour() + ":" + myTime.getMinute() + ":" + myTime.getSecond());// 同样，LocalDateTime也是可以通过of方法创建特定日期LocalDateTime myDateTime = LocalDateTime.of(2018, Month.JUNE, 4, 10, 30, 45);System.out.println(myDateTime.getYear() + "/" + myDateTime.getMonthValue() + "/" + myDateTime.getDayOfMonth()+ " " + myDateTime.getHour() + ":" + myDateTime.getMinute() + ":" + myDateTime.getSecond());// 也提供了LocalDate 和 LocalTime组合而成的LocalDateTimeLocalDateTime myDateTime2 = LocalDateTime.of(myDate, myTime);System.out.println(myDateTime2.getYear() + "/" + myDateTime2.getMonthValue() + "/" + myDateTime2.getDayOfMonth() + " " + myDateTime2.getHour() + ":" + myDateTime2.getMinute() + ":" + myDateTime2.getSecond()); 格式化123456789 */// date --&gt; StringLocalDate formatDate1 = LocalDate.of(2014, 3, 3);String dateString = formatDate1.format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));System.out.println(dateString);// String --&gt; dateLocalDate formatDate2 = LocalDate.parse(dateString, DateTimeFormatter.ofPattern("yyyy/MM/dd"));System.out.println(formatDate2); 日期转换1234567891011// LocalDate --&gt; LocalDateTimeLocalDate changeDate = LocalDate.of(2018, 12, 4);LocalDateTime changeDateTime = changeDate.atTime(10, 20, 30);System.out.println(changeDateTime);// LocalTime --&gt; LocalDateTimeLocalTime changeTime = LocalTime.of(10, 20, 30);LocalDateTime changeDateTime2 = changeTime.atDate(LocalDate.of(2018, 12, 4));System.out.println(changeDateTime2);// LocalDateTime --&gt; LocalDate,LocalTime 有这样的api toLocalDate toLocalTimeSystem.out.println(changeDateTime.toLocalDate());System.out.println(changeDateTime2.toLocalTime()); 日期加减123456789101112LocalDate now = LocalDate.now();// 2天后System.out.println(now.plusDays(2L));// 3天前System.out.println(now.minusDays(3L));// 一年后System.out.println(now.plusYears(1));// 2周前System.out.println(now.minus(2L, ChronoUnit.WEEKS));// 3年2月1天后System.out.println(now.plus(Period.of(3, 2, 1))); 计算间隔123456789LocalDateTime before = LocalDateTime.of(2011, 2, 11, 11, 11, 11);LocalDateTime after = LocalDateTime.of(2014, 2, 11, 11, 11, 11);// Duration 来表示间隔Duration between = Duration.between(before, after);// 间隔的天System.out.println("间隔：" + between.toDays());// 间隔的分钟System.out.println("间隔：" + between.toMinutes()); 日期比较12345LocalDate compareDate1 = LocalDate.of(2011, 1, 1);LocalDate compareDate2 = LocalDate.of(2012, 1, 1);System.out.println(compareDate1.isBefore(compareDate2));int i = compareDate1.compareTo(compareDate2);System.out.println("c1 compareTo c2 is " + i); 和java.util.Date的转换1234567891011121314151617// LocalDateTime --&gt; Instant --&gt; DateLocalDateTime currentLocalDateTime = LocalDateTime.now();Instant instant = currentLocalDateTime.atZone(ZoneId.systemDefault()).toInstant();Date date1 = Date.from(instant);System.out.println(date1);// Date --&gt; Instant --&gt; LocalDateTimeDate date2 = new Date();Instant instant1 = date2.toInstant();LocalDateTime dateTime1 = LocalDateTime.ofInstant(instant1, ZoneId.systemDefault());System.out.println(dateTime1);// Calendar --&gt; Instant --&gt; LocalDateTimeCalendar calendar = Calendar.getInstance();Instant instant2 = calendar.toInstant();LocalDateTime dateTime2 = LocalDateTime.ofInstant(instant2, ZoneId.systemDefault());System.out.println(dateTime2);]]></content>
      <categories>
        <category>Java语法</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot配置jsp]]></title>
    <url>%2Fblog%2F2018%2F10%2F23%2Fspring-boot%E9%85%8D%E7%BD%AEjsp%2F</url>
    <content type="text"><![CDATA[spring-boot中jsp的使用jsp是之前在学习java开发中会学习到的知识，虽然现在公司中虽然使用jsp越来越少，但是spring-boot配置jsp的使用还是应该去记录一下。 相关依赖增加这里要加入一些依赖： 123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jsper渲染引擎 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 内置tomact --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jstl 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; 还要需要注意的是spring-boot默认打包方式jar包的形式，这里要换成war包的方式。 激活传统Servlet web部署springboot1.4版本之后通过实现org.springframework.boot.web.support.SpringBootServletInitializer抽象类中的抽象方法来将启动类添加到souce中 12345678public class JspConfig extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; // source启动类 告知一些静态资源 builder.sources(SpringBootDemoApplication.class); return builder; &#125;&#125; 加入资源目录位置在项目的src/main目录下建立一个webapp文件夹，这个webapp目录下建立WEB-INFO和jsp文件夹，写一个index.jsp文件作为之后的测试页面。 目录： 12345&lt;html&gt;&lt;body&gt;hello, $&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 设置访问资源文件的前缀和后缀在application.properties配置文件中配置访问jsp文件中的prefix和suffix，注意这里这prefix中的开头和结尾的/是不能省略的，否则会访问不到你的资源。 123# 访问jsp资源的前缀和后缀spring.mvc.view.prefix = /WEB-INFO/jsp/spring.mvc.view.suffix = .jsp 写一个test的controller在配置好了之后，写一个controller作为入口去访问这个jsp文件 1234567891011@Controllerpublic class JspController &#123; @RequestMapping(value = "/index") public String index(Model model) &#123; model.addAttribute("message", "zlj"); return "index"; &#125;&#125; 这时候在浏览器中输入localhost:7001/index即可访问到我们返回给index.jsp中message占位符的字符串值。]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>actuator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——ThreadPoolExecutor源码分析（二）]]></title>
    <url>%2Fblog%2F2018%2F10%2F11%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言在上一篇中，我们分析了ThreadPoolExecutor中关键变量ctl，这篇我们继续来看ThreadPoolExecutor中的构造函数及其参数。其中参数的相关解释来源于源码中的相关注释。 构造函数我们可以看到ThreadPoolExecutor有四个构造函数： 他们其实都是调用其中的全参数的构造函数，只不过有一些参数是使用了默认提供的参数。我们可以看一下构造函数： 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 可以看到构造函数现对于参数去进行了校验：（1）corePoolSize必须大于等于0，maximumPoolSize必须大于0，maximumPoolSize必须大于等于corePoolSize，keepAliveTime如果传入了必须大于0。 （2）workQueue、threadFactory、handler不能为空 （3）其中有acc字段的设置是为了设置安全管理器，我们可以自定义我们的安全管理器，否则为从上下文中去拿。可以参考博客：jvm中的安全管理器 构造函数中的参数1.corePoolSizecorePoolSize参数表示线程池中一直存活的线程的最小数量，这些一直存活的线程被称为核心线程，默认情况下，核心线程的最小数量都是整数，除非是调用了allowCoreThreadTimeout()方法并且传入了true，即允许核心线程数在空闲状态下超时而停止（terminated状态），此时如果所有的核心线程先后都因为超时停止，那么线程池中核心线程数会变为0。默认情况下，核心线程是按照需要创建并启动的，也就是说只有当线程池接收到我们提交的任务后，它才会去创建并启动一定的核心线程去执行这些任务。如果没有接收到相关任务，就不会去主动创建核心线程，这种默认的核心线程创建启动方式变主动为被动，类似于观察者模式，有利于降低系统资源的消耗。当然，也可以通过设置preStartCoreThread()或者preStartAllCoreThreads()方法来改变这一机制，使得在新任务还未提交到线程池的时候，线程池就已经创建并启动了一个或所有线程，并让这些核心线程在池中等待任务的到来。 2.maximumPoolSizemaximumPoolSize表示线程池中能容量线程的最大数量，这个值不能超过常量CAPACITY的数值大小，上一篇中也提到了常量CAPACITY的计算方式，这里不去赘述。但是注意一点，当我们提供的工作队列是一个无界的队列，那么这里提供的maximumPoolSize将毫无意义。 当我们通过execute方法提交一个任务的时候： （1）如果线程池处于运行状态（RUNNING）的线程数量小于核心线程数（corePoolSize），那么即使有一些非核心线程处于空闲状态，系统也倾向于新建一个线程来处理这个任务。 （2）如果线程池处于运行状态（RUNNING）的线程数量大于核心线程数（corePoolSize），但又小于maximumPoolSize，那么系统会去判断线程池内部的阻塞队列是否有空位子，如果有空位子，系统会将该任务先存入阻塞队列，如果发现队列中已没有空位子（即队列已满），系统会创建一个新的线程来执行任务。 如果将线程池中的corePoolSize和maximumPoolSize设置为相同的数（也就是说线程池中所有线程都是核心线程），那么该线程池就是一个固定容量的池子。如果将线程池的maximumPoolSize设置为一个非常大的数值（例如Integer.MAX_VALUE），那么相当于允许线程池自己在不同时段调整参与并发的总任务数。通常情况下，都是通过构造函数去初始化corePoolSize和maximumPoolSize，也可以通过set方法调整这两个参数的大小。 3.keepAliveTime &amp; unitkeepAliveTime表示空闲线程处于等待的超时时间，超过该时间后该线程会停止工作。当线程池中总线程数量大于corePoolSize并且allowCoreThreadTimeOut为false时，这些多出来的非核心线程一旦进入空闲等待的状态，就开始计算各自的等待时间，并且这里设定的keepAliveTime的数值作为他们的超时时间，一旦某个非核心线程的等待时间到达了超时时间，该线程就会停止工作（terminated）。而如果不去设置allowCoreThreadTimeout为true，核心线程及时处于空闲状态等待了keepAliveTime，也依然可以继续处于空闲状态等待。 比较好的应用实践： 如果要执行的任务相对较多，并且每个任务执行的时间都比较短，那么可以为keepAliveTime参数设置一个相对较大的值，以提高线程的利用率；如果要执行的任务比较少，线程池使用率比较低，那么可以先将该参数设置为一个较小的参数值，通过超时停机的机制来降低系统资源的开销。 注意一点：构造函数中的参数keepAliveTime和unit这个参数和ThreadPoolExecutor中的keepAliveTime字段的值不一定相等，字段被设置为long型的值，且定义为纳秒的单位，构造函数中的参数还有unit单位，应该是keepAliveTime和unit计算的结果换算为纳秒才和类中的字段是一样的值。 keepAliveTime在构造函数中的类型是long型，这样保证了这个值不会太短。 4.workQueue构造函数中的workQueue是一个BlockIngQueue（阻塞队列）的实例。传入的泛型参数是Runnable，也就是说，workQueue是一个内部元素为Runnable（各种任务，通常是异步的任务）的阻塞队列。阻塞队列是一种类似于”生产者-消费者“模式的队列，当队列已满时如果继续向队列中插入元素，该插入操作将被阻塞一直处于等待状态，直到队列中有元素被移除，才能进行插入操作；当队列为空时如果继续执行元素的删除或者获取操作，也会被阻塞进入等待队列中有新的元素之后才能执行。 workQueue是一个用于保存等待执行的任务阻塞队列，当提交一个新的任务到线程池后，线程池会根据当前池子正在运行的线程数量来判断对这个任务的处理方式： （1）如果线程池中正在运行的线程数少于核心线程数，那么线程池总是倾向于新建一个线程来执行该任务。 （2）如果线程池中正在运行的线程数不少于核心线程数，那么线程池把该任务提交到workQueue中让其先等待 （3）如果线程池中正在运行的线程数不少于核心线程数，并且线程池中的阻塞队列也满了使得该任务入队失败，那么线程池会去判断当前池子中运行的线程数是否已经等于了该线程池允许运行的最大线程数。如果发现已经等于，说明池子已满，那么就会执行拒绝策略；如果发现运行的线程数小于池子允许的最大线程数，那么会创建一个线程（这个线程是非核心线程）来执行该任务。 这其中，队列对于提交的任务一般有三种策略：（1）直接切换 常用的队列是SynchronousQueue（同步队列）,这个队列内部不会存储元素，每一次插入操作都会先进入阻塞状态，一直等到另一个线程执行了队列的删除操作，然后该插入操作才会执行。当提交一个任务到包含这种SynchronousQueue队列的线程池后，线程池会去检测是否有可用的线程来执行任务，如果没有则创建一个新的线程来执行任务而不是将任务存储在任务队列中。”直接切换“的意思是：处理方式由”将该任务暂时存储在阻塞队列中“直接切换为”新建一个线程来处理任务“。这种执行策略适合处理多个有相互依赖关系的任务，因为该策略可以避免这些任务因一个没有及时处理而导致依赖于该任务的其他任务也不能及时处理而造成的锁定结果。因为这种策略的目的是要让几乎每一个新提交的任务都能立即得到处理，所以这种策略通常配合maximumPoolSize是无边际（Integer.MAX_VALUE）的。我们知道的静态工厂方法Executors.newCachedThreadPool()就是使用了这种直接切换的队列。 （2）使用无界队列 不预设队列的容量，队列将使用Integer.MAX_VALUE作为默认容量，例如：基于链表的阻塞队列 LinkedBlockingQueue。使用无界队列使得线程池中能创建的最大线程数等于核心线程数，这样的线程池的maxmumPoolSize的数值将不起任何作用。如果向线程池中提交一个新任务时发现所有的核心线程都处于运行状态，那么该任务将被放入无界队列中等待处理。当要处理的多个任务之间没有相互依赖关系的时候，就适合用这种队列策略来处理这些任务。静态工厂方法Executors.newFixedThreadPool()就使用了这个队列。 （3）使用有界队列 例如使用基于数组的阻塞队列 ArrayBlockingQueue。当要求线程池的最大线程数maximumPoolSize要限定在某个值以内的时候，线程池使用有界队列能降低资源的消耗，但这也使得线程池对线程的调控变得更加困难。因为队列容量和线程池容量都是有限的值，要想使线程处理任务的吞吐量在一个相对合理的范围内，同时又能使线程调度的难度相对较低，并且又尽可能节省系统资源的消耗，那么需要合理的调配这两个值。通常来说，设置较大的队列容量和较小的线程池容量，能够降低系统的资源的消耗（包括CPU的使用率，操作系统的消耗，上下文环境的切换的开销等），但是会降低系统吞吐率。如果发现提交的任务经常频繁的发生阻塞的情况，那么你可以考虑增大线程池的容量，可以通过setMaximumPoolSize()方法来重新设定线程池的容量。而设置较小的队列量时，通常需要将线程池的容量设置大一点，这种情况下，cpu的使用率会比较高，但是如果设置线程池的容量过大的时候，线程调度成了问题，反而使得吞吐率比较低。 5.threadFactory线程工厂，用于创建线程。默认使用Executors.defaultThreadFactory()方法创建线程工厂： 当然我们也可以自己实现ThreadFactory接口去实现我们自己的线程工厂。下边就是可以根据不同的namePrefix去获取单例线程的线程工厂： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 自定义线程工厂类 */private static class MyThreadFactory implements ThreadFactory &#123; /** * namePrefix --&gt; 线程名字中的计数 */ private static Map&lt;String, AtomicInteger&gt; THREAD_ID_TABLE = new ConcurrentHashMap&lt;&gt;(); /** * 线程名称前缀 */ private String namePrefix; /** * 是否后台线程 */ private boolean isDamon; public MyThreadFactory(String namePrefix) &#123; this(namePrefix, true); &#125; public MyThreadFactory(String namePrefix, boolean isDamon) &#123; this.namePrefix = namePrefix; this.isDamon = isDamon; &#125; @Override public Thread newThread(Runnable r) &#123; String threadName = namePrefix + "-" + generateThreadId(this.namePrefix); Thread thread = new Thread(r, threadName); thread.setDaemon(this.isDamon); System.out.println("创建线程" + threadName); return thread; &#125; private static int generateThreadId(String namePrefix) &#123; // 判断后执行 concurrentHashMap不能保证完全线程安全 用了putIfAbsent if (!THREAD_ID_TABLE.containsKey(namePrefix)) &#123; THREAD_ID_TABLE.putIfAbsent(namePrefix, new AtomicInteger(0)); &#125; return THREAD_ID_TABLE.get(namePrefix).getAndIncrement(); &#125;&#125; 6.handler当满足以下两个条件其中一个的时候，如果继续向线程池中提交新的任务，那么线程池会调用内部的RejectedExecutionHandler对象的rejectedExecution()方法，表示拒绝执行这些新提交的任务： （1）当线程池处于SHUTDOWN状态时（不论线程池和阻塞队列是否已满） （2）当线程池中所有的线程都处于运行状态并且线程池中的阻塞队列已满。 一个demo去演示这两个情况：执行handler的两种情况 当采用默认的拒绝策略，线程池会使用抛出异常的方式来拒绝新任务的提交，这种拒绝方式在线程池中被称为AbortPolicy，我们可以来看下有哪些拒绝策略：（1）AbortPolicy 这中处理方式是直接抛出RejectedExecutionException异常，如果在ThreadPoolExecutor的构造函数中未指定RejectedExecutionHandler参数，那么线程池将使用defaultHandler参数，而这个就是采用的AbortPolicy。 （2）CallerRunsPolicy 将提交的任务放在ThreadPoolExecutor.execute()方法所在的那个线程执行。 （3）DiscardPolicy 直接不执行新提交的任务 （4）DiscardOldestPolicy 这个可以看源码中的解释： 由源码就可以知道，这种处理方式有两种情况：一，当线程池处于SHUTDOWN状态时，就默认不执行这个任务，即DiscardPolicy；二，当线程池处于运行状态时，会将队列中处于队首（head）的那个任务从队列中移除，然后将这个新提交的任务加入到阻塞队列中的队尾（tail）等待执行。 当然，RejectedExecutionHandler其实是个接口，我们可以自定义类去实现这个接口，重写rejectedExecution方法使用自己想要的拒绝策略即可。 下一篇这篇把线程池中的核心参数进行了一些解释，在下一篇中我们将介绍线程池进行任务调度的原理。]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8增加的接口中默认方法]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fjava8%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言最近在工作中的一次小修改让自己应用到了java8中的新特性：接口默认方法，这里去简单记录下。在java8之后可以在接口定义方法的实现，成为default方法，类似于Scala中的trait。比如在Iterable接口中新增了foreach默认方法： 12345678910111213141516171819202122232425/** * Performs the given action for each element of the &#123;@code Iterable&#125; * until all elements have been processed or the action throws an * exception. Unless otherwise specified by the implementing class, * actions are performed in the order of iteration (if an iteration order * is specified). Exceptions thrown by the action are relayed to the * caller. * * @implSpec * &lt;p&gt;The default implementation behaves as if: * &lt;pre&gt;&#123;@code * for (T t : this) * action.accept(t); * &#125;&lt;/pre&gt; * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; 这个default方法的主要目的是为java8的Lambda表达式提供支持，如果将这个方法定义为普通接口方法，则会对现有的JDK的其他使用Iterable接口的类造成影响，因此提供了default方法的功能。 工作中的例子有一个小需求是对一个表的插入的实体的name字段做一个处理，这里name字段如果为空则用手机号（默认手机号不为空）进行插入。因为调用这个insert方法的业务代码比较多，每个都去做这个逻辑会显得很麻烦并且很重复。所以就想到了直接在mapper的xml中去进行修改： 12345insert into table_name ( &lt;if test=&quot;name ==null or name == &apos;&apos;&quot;&gt;NAME,&lt;/if&gt; ) values( &lt;if test=&quot;name == null or name == &apos;&apos;&quot;&gt;#&#123;mobile&#125;&lt;/if&gt;) 这样确实能够实现我们这个小需求，但是这个insert的mapper.xml是通过代码工具自动生成的标准insert方法，并且这样写可读性也不好，给人一种很奇怪的感觉。 这时候就用到了默认方法。这里我们可以在接口中定义一个默认方法insert，然后将之前的insert方法更换名称，在默认方法中去调用更换之后插入方法，而在默认方法中去做如果name为空则用手机号去代替这个逻辑。 12345678910111213int insertDefault(Clues entity);/** * * @param entity * @return */default int insert(Clues entity) &#123; if (StringUtils.isEmpty(entity.getName()) &amp;&amp; StringUtils.isNotEmpty(entity.getMobile())) &#123; entity.setName(entity.getMobile()); &#125; return insertDefault(entity);&#125; 这样原来调用的insert方法也不需要去做更改，并且也不用在xml中进行改动就实现了这个小逻辑。注意要将xml中方insert方法改为insertDefault，这个更改比上边那种修改要显得合理的多。 默认方法的一个总结java是面向对象的语言，那么就会有实现接口和继承父类，那么这些会对接口的默认方法有什么影响呢？下边参考博客：默认方法 存在一个父接口，定义了一个default方法： 12345public interface Parent &#123; default String doit() &#123; return &quot;Parent&quot;; &#125;&#125; 有一个类实现该接口，使用了默认的default方法： 123public class ParentImpl implements Parent&#123;&#125; 有一个ParentImpl2继承了ParentImpl，里面重写了接口中的默认方法： 1234567public class ParentImpl2 extends ParentImpl &#123; @Override public String doit() &#123; return &quot;ParentImpl2&quot;; &#125;&#125; 有一个Child接口继承了Parent接口，并且重写了Parent接口中的默认方法： 12345678910public interface Child extends Parent &#123; /** * 重写父接口中的default方法 * @return */ @Override default String doit() &#123; return &quot;Child&quot;; &#125;&#125; 有一个ChildImpl实现了Child： 12public class ChildImpl implements Child &#123;&#125; 又有一个ChildImpl2继承了ParentImpl2也实现了Child接口，为了测试当子类实现的接口和继承的父类中都有默认方法的场景: 12public class ChildImpl2 extends ParentImpl2 implements Child &#123;&#125; 测试类： 123456789101112131415161718192021222324252627282930313233public class Main &#123; public static void main(String[] args) &#123; /** * 测试实现类可以直接调用接口中的default方法 */ Parent parentImpl = new ParentImpl(); // 将输出Parent System.out.println(parentImpl.doit()); /** * 测试Child接口重写了Parent接口的default方法 */ Child child = new ChildImpl(); // 将输出Child System.out.println(child.doit()); /** * 测试ParentImpl2重写了Parent接口中default方法 */ Parent parentImpl2 = new ParentImpl2(); // 将输出ParentImpl2 System.out.println(parentImpl2.doit()); /** * 测试ChildImpl2父类和实现的接口都有default方法，优先使用父类中定义的方法 */ Child childImpl2 = new ChildImpl2(); // 将输出ParentImpl2 System.out.println(childImpl2.doit()); &#125;&#125; 从上述测试结果可以看出： 实现类可以直接使用父接口中定义的default方法。 接口可以重写父接口中定义的default方法。 实现类可以重写父接口中定义的方法、 当父类和父接口都存在default方法时，使用父类中重写的default方法 特别的，如果一个类实现了两个接口，这两个接口中有同名的default方法签名时，此时会编译不通过，必须在子类中重写这个default方法。]]></content>
      <categories>
        <category>Java语法</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>接口默认方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——ThreadPoolExecutor源码分析（一）]]></title>
    <url>%2Fblog%2F2018%2F10%2F04%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言线程池是并发编程中最重要的应用之一，使用线程池可以防止大量的创建和销毁线程的过程，可以节省很多的内存空间，提高程序的响应率和cpu的利用率，并且也可以对线程进行统一管理和监控。这里将分几篇文章介绍一下线程池的源码分析。本篇是分析ThreadPoolExecutor中的ctl变量。并且去写了线程中的 ctl变量源码中的解释ThreadPoolExecutor中有个字段是ctl，具体来说是对线程池的运行状态和池子中的有效线程数量的控制的一个字段变量，我们可以看看源码中的解释： 123456789101112/** * The main pool control state, ctl, is an atomic integer packing * two conceptual fields * workerCount, indicating the effective number of threads * runState, indicating whether running, shutting down etc * * In order to pack them into one int, we limit workerCount to * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2 * billion) otherwise representable. If this is ever an issue in * the future, the variable can be changed to be an AtomicLong, * and the shift/mask constants below adjusted. But until the need * arises, this code is a bit faster and simpler using an int. 可以看到ctl是AtomicInteger对象，里面的操作都是基于CAS的原子操作。一个ctl变量包含两部分信息，因为int类型的变量是32位的，所以高3位表示线程池的运行状态（runState），低29位表示线程池中有效线程数（workerCount）。 所以，当我们知道了线程池中的运行状态和有效线程数，就可以通过ctlOf方法计算出ctl的值： 1private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 反过来，我们也可以通过ctl计算出runState和workerCount的值： 12private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; 其中CAPACITY是(2^29)-1， 也就是高三位是0，低29位是1的一个int类型的数字常量。这个CAPACITY表示线程池中有效线程的上限值。这个值的计算过程： 12private static final int COUNT_BITS = Integer.SIZE - 3; // 29private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; 线程池的状态线程池中有五种状态： 123456// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 其中COUNT_BITS的值是29，在后边的源码分析过程中，我们其实只需要知道这几个状态是逐渐递增的即可。比如说在源码中看到 rs &lt; SHUTDOWN 其实就是表示此时线程池的运行状态是RUNNING。 五种状态的解释： （1）RUNNING：运行状态，能接受提交新的任务，并且也能处理阻塞队列中的任务。 （2）SHUTDOWN：关闭状态，不再接受新提交的任务，但是可以处理阻塞在任务队列中已保存的任务。在线程池处于RUNNING状态的时候，调用shutdown方法线程池即变为此状态。 （3）STOP：停止状态，不再接受新提交的任务，也不会处理阻塞队列中已保存的任务，并且会中断正在处理的任务，在线程池处于RUNNING状态或者SHUTDOWN状态的时候，调用shutdownNow方法线程池即进入该状态。 （4）TIDYING：清理状态，所有的任务都已经终止，workerCount有效线程数量为0，线程池进入该状态后调用terminated方法可以使线程池进入Terminated状态。当线程池处于SHUTDOWN状态时，如果此后线程池中没有线程并且阻塞队列中没有要执行的任务，就会进入到这个状态；当线程池处于STOP状态时，如果此时线程池中没有线程了，线程池会进入该状态。（5）TERMINATED：terminated()方法执行之后会进入该状态。 其他字段参数12345678910111213141516171819202122232425262728293031323334//线程池控制器private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));//任务队列private final BlockingQueue&lt;Runnable&gt; workQueue;//全局锁private final ReentrantLock mainLock = new ReentrantLock();//工作线程集合private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();//终止条件 - 用于等待任务完成后才终止线程池private final Condition termination = mainLock.newCondition();//曾创建过的最大线程数private int largestPoolSize;//线程池已完成总任务数private long completedTaskCount;//工作线程创建工厂private volatile ThreadFactory threadFactory;//饱和拒绝策略执行器private volatile RejectedExecutionHandler handler;//工作线程活动保持时间(超时后会被回收) - 纳秒private volatile long keepAliveTime;/** * 允许核心工作线程响应超时回收 * false：核心工作线程即使空闲超时依旧存活 * true：核心工作线程一旦超过keepAliveTime仍然空闲就被回收 */private volatile boolean allowCoreThreadTimeOut;//核心工作线程数private volatile int corePoolSize;//最大工作线程数private volatile int maximumPoolSize;//默认饱和策略执行器 - AbortPolicy -&gt; 直接抛出异常private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 下一章下一章将会去写一下ThreadPoolExecutor的构造函数和核心参数。]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi命令小总结（二）]]></title>
    <url>%2Fblog%2F2018%2F09%2F30%2Fvi%E5%91%BD%E4%BB%A4%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在vi编辑模式下显示行数在vi编辑模式下可以显示下行数，比如在php调试模式下可以根据相应的行数的代码去打印值调试代码。 方法：在vi模式下输入:set nu即可。也可以直接:line number跳转到对应的行数。 在vi编辑模式中撤回一个操作在INSERT模式下如果写了一些操作，然后想撤回这个操作，按一下esc之后输入u即可。如果是想撤回刚才那个撤回操作，可以按了esc之后点击Ctrl + r。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vi命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot配置swagger]]></title>
    <url>%2Fblog%2F2018%2F09%2F24%2Fspring-boot%E9%85%8D%E7%BD%AEswagger%2F</url>
    <content type="text"><![CDATA[前言swagger是一个很好的restful形式的api文档，可以通过比较小的侵入来提供很好的restful的文档。因为swagger是依赖服务生成的，所以其实是依赖服务的，这也算是它的一个小缺点吧。但是其实如果一个项目习惯去手写文档之后，也是可以的，但是新的项目还是建议去用一些自动生成的文档，省去了很多麻烦。 spring boot配置swagger引入swagger依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 编写swagger对应的配置1234567891011121314151617181920212223242526272829303132333435363738import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; // 文档类型 return new Docket(DocumentationType.SWAGGER_2) // 创建api的基本信息 .apiInfo(apiInfo()) // 选择哪些接口去暴露 .select() // 扫描的包 .apis(RequestHandlerSelectors.basePackage(&quot;com.demo.web.controller&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;groundhog-web swagger文档&quot;) .contact(&quot;name&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; 在api和请求参数中使用注解接口中使用swagger注解 123456789101112@RestController@Api(value = &quot;测试swagger&quot;, description = &quot;测试swagger api&quot;)public class TestSwaggerController &#123; @ApiOperation(value = &quot;返回url中的参数&quot;, notes = &quot;返回url中的参数&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;id值&quot;, paramType = &quot;path&quot;, required = true, dataType = &quot;Integer&quot;) @GetMapping(path = &quot;/getUrlParam/&#123;id&#125;&quot;) public Integer getUrlParam(@PathVariable(value = &quot;id&quot;) Integer id) &#123; return id; &#125;&#125; 可以访问localhost:port/swagger-ui.html看到生成的swagger文档。可以看到请求结果： 也可以看到之前post方法的接口也可以生成对于的参数文档，这里也可以对表单参数bean使用@ApiModel和@ApiProperty注解进行标识。 swagger相关注解和官方文档swagger常用注解： @Api：修饰整个类，描述controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiProperty：用对象接收参数时，描述对象的一个字段 @ApiImplicitParam：一个请求参数 @ApiImplicitParams：多个请求参数 这里推荐下官方文档，感兴趣可以看一下其他注解和相关配置： 注解官方文档]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个切面配置的记录]]></title>
    <url>%2Fblog%2F2018%2F09%2F21%2F%E4%B8%A4%E4%B8%AA%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言之前也学习过validate注解去校验一些参数的必要条件，这回工作中用的时候遇到了一些问题。这里都是使用spring boot框架去做的切面，省去了很多不需要的配置。这里去记录一下。 两个切面validate注解这里主要是去使用了hibernate中的注解而去做的切面，之前在博客中写到的整合了两个标准的注解的切面（注意区分下）。看一下切面的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@Aspect@Configurationpublic class ValidateAspect &#123; /** * BEAN对象校验器 配置快速失败模式 */ private final Validator BEAN_VALIDATOR = Validation.byProvider(HibernateValidator.class) .configure() //快速失败模式开启，当检测到有一项失败立即停止 .failFast(true) .buildValidatorFactory().getValidator(); /** * 方法参数对象校验器 */ private final ExecutableValidator METHOD_VALIDATOR = BEAN_VALIDATOR.forExecutables(); /** * point配置 */ @Pointcut(&quot;execution(* com.zhanglijun.springbootdemo.web.controller..*.*(..))&quot;) public void pointcut() &#123; &#125; @Before(&quot;pointcut()&quot;) public void before(JoinPoint point) &#123; // 获得切入目标对象 Object target = point.getThis(); // 获得切入方法参数 Object [] args = point.getArgs(); // 获得切入的方法 Method method = ((MethodSignature)point.getSignature()).getMethod(); // 校验以基本数据类型 为方法参数的 checkWithResult(validMethodParams(target, method, args)); // 校验以java bean对象 for (Object bean : args) &#123; if (null != bean) &#123; checkWithResult(validBeanParams(bean)); &#125; &#125; &#125; /** * 校验bean对象中的参数 * @param bean * @param &lt;T&gt; * @return */ private &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validBeanParams(T bean) &#123; return BEAN_VALIDATOR.validate(bean); &#125; /** * 校验方法中的参数 * @param obj * @param method * @param params * @param &lt;T&gt; * @return */ private &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validMethodParams(T obj, Method method, Object [] params)&#123; return METHOD_VALIDATOR.validateParameters(obj, method, params); &#125; /** * 校验参数校验结果 * @param set */ private void checkWithResult(Set&lt;ConstraintViolation&lt;Object&gt;&gt; set) &#123; if (CollectionUtils.isEmpty(set)) &#123; return; &#125; Iterator&lt;ConstraintViolation&lt;Object&gt;&gt; methodIterator = set.iterator(); if (methodIterator.hasNext()) &#123; throw new IllegalArgumentException(methodIterator.next().getMessage()); &#125; &#125;&#125; 这个可以去实现validate注解的切面配置。 访问接口信息注解还有就是参考翟DD博客中的spring boot配置的一个记录访问接口信息的切面，这里在配置了之后遇到了两个问题，去记录一下。 切面配置12345678910111213141516171819202122232425262728293031323334353637@Aspect@Configuration@Slf4jpublic class WebRequestAspect &#123; // TODO 可以加上sessionUser的获取 @Pointcut(&quot;execution(* com.zhanglijun.springbootdemo.web.controller..*.*(..))&quot;) public void webLog()&#123;&#125; @Before(&quot;webLog()&quot;) public void doBefore(JoinPoint joinPoint) &#123; // 获取request对象 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes == null) &#123; return; &#125; HttpServletRequest request = attributes.getRequest(); log.info(&quot;REQUEST_URL : &#123;&#125;, HTTP_METHOD : &#123;&#125;, ARGS : &#123;&#125;&quot;, request.getRequestURL().toString(), request.getMethod(), JSON.toJSONString(joinPoint.getArgs())); &#125; @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;) public void doAfterReturning(Object ret) &#123; // 打印返回内容 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes == null) &#123; // 容器启动时也去初始化了切面（因为是execution）这里去判断一下 return; &#125; HttpServletRequest request = attributes.getRequest(); log.info(&quot;REQUEST_URL : &#123;&#125;, RESPONSE : &#123;&#125; &quot;, request.getRequestURL(), JSON.toJSONString(ret)); &#125;&#125; 问题1 fastJson去打印入参在doBefore方法中去做了对方法参数的打印，这里没有思索去用了fastJson去打印参数，但是当去访问一个参数中带有response对象的时，会发生报错。 接口： 123456//========================= 测试web log切面 =====================@GetMapping(path = &quot;/testAspect&quot;, produces = MediaType.APPLICATION_JSON_VALUE)public void testAspect(HttpServletResponse response) &#123; log.info(&quot;测试web log 切面 fastJson序列化response对象会报错&quot;);&#125; 报错： 这个错误在网上找了比较久，也跟进去源码看了，reponse的getOutputSteam在走到切面的这个输出的时候，已经被调用过了，会有一个标志位标志其被调用过，这里如果用fastJson去序列化这个response对象，这里会报错。这就提醒我们这里输出参数不能去使用fastJson去序列化。（有的mapping还是会去用到response对象）。修改方法就是可以把输出参数的部分改成Arrays.toString进行输出。 1Arrays.toString(joinPoint.getArgs())); 这里要注意参数内部的toString方法的实现。 request对象获取的问题这个切面中因为要记录访问的url，所以用到了HttpServletRequest对象，这里获取的方式是：RequestContextHolder.getRequestAttributes()；这个实现的原理就是请求到来的时候去使用ThreadLocal放入request对象，所以在@AfterReturning中也可以去使用这个对象（因为这次请求还没有结束）。但是在项目初始化时，这个切面就会被加载一次，此时并没有请求所以ThreadLocal中也不会有这个request对象。 解决办法：我这里去对request对象做了判断，如果是null的话，那么方法直接返回。 这里也可以去写一下@AfterThrowing之后的处理，可以直接throw出去交给统一异常处理。这里注意切面的order属性和数据层面的事务的order大小顺序。order越小，执行的越靠前。 当你的切面order&gt;数据层面的事务order时，执行顺序是: transaction -&gt; doBefore -&gt; Exception -&gt; @AfterThrowing -&gt; rollback。注意这个时候会造成你的@AfterThrowing内容不生效，一起rollback了。 而当你的切面order &lt; 数据层面事务order时，执行顺序是： dobefore -&gt; transaction -&gt; exception -&gt; rollback -&gt; @AfterThrowing 所以要配置你的webLog切面的order小一些。在spring boot框架中可以通过@Order(level)在类上加上注解进行order控制。]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>validate注解</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi命令小总结]]></title>
    <url>%2Fblog%2F2018%2F09%2F09%2Fvi%E5%91%BD%E4%BB%A4%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言这篇去写一些最近在工作中get到的关于vi/vim命令的点，简单去记录下。 技能点在文件中快速删除一行在vi编辑文件的时候，发现有时要删除很多的文件内容，这个时候去一点点删除很慢，这里get到了一个快速删除一行的技能。在打开的文件中所要删除的行连续按两次d就可以快速删除一行，然后在用:wq保存即可。 解决没有正确关闭vi打开的文件有的时候我们在查看一个文件之后，直接ctrl+z去退出了文件，当我们再用vim命令去编辑文件的时候，这时候会发现报一个没有正确关闭这个文件的冲突错误，并且你不去解决就会一直存在。 这里get到了去解决的方法，其实也是怪自己一看到一堆英文就不想看下去，这里其实已经写得很清楚了，这里提供了两种情况： （1）有可能另一个人也在编辑这个文件，它提醒你要注意两个人同时编辑不同的地方。 （2）上一次编辑的session还在，这时候提供了解决办法：可以用recover或者vim -r 文件名去修复这个changes。 可以看到当你没正确退出时，还保持着edit session，这时候会生成两个临时文件，我这里采用的是直接删除这两个文件即可。 运行 rm -rf .fileName.* 命令之后，再次打开之后就不会有冲突。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vi命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot应用拦截器]]></title>
    <url>%2Fblog%2F2018%2F09%2F05%2Fspringboot%E5%BA%94%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[背景在工作中看到了不少项目用到了拦截器，这里去总结一下spring-boot使用拦截器。拦截器是Spring提供的HandlerInterceptor（拦截器），其功能和过滤器类似，但是提供更精细的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request的内容，但可以通过抛出异常（或者返回false）来暂停request的执行。 使用步骤配置拦截器也很简单，spring给我们提供了WebMvcConfigurerAdapter，我们在addInterceptors方法中添加注册拦截器即可。总结起来就是三步： 1.创建我们自己的拦截器类并实现HandlerInterceptor接口。 2.创建一个Java类继承WebMvcConfigurerAdapter，并重写addInterceptors方法。 3.实例化我们自定义的拦截器，然后将对象手动添加到拦截器链中。 代码示例自定义Session信息写入ThreadLocal12345678910111213141516171819202122232425262728293031323334@Slf4j@Componentpublic class SessionInterceptor implements HandlerInterceptor &#123; @Resource private RequestHelper requestHelper; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; log.info(&quot;SessionInterceptor preHandle方法，在请求方法之前调用，Controller方法调用之前&quot;); // MOCK一个SessionUser对象，放入ThreadLocal中 SessionUser sessionUser = new SessionUser(); sessionUser.setId(2L).setName(&quot;夸克&quot;); requestHelper.setSessionUser(sessionUser); // 只有这个方法返回true 请求才能继续下去 return true; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;SessionInterceptor postHandle方法，请求处理之后调用，但是在视图被渲染之前（Controller方法调用之后）&quot;); // 这里可以去做sessionUser的清除 防止内存泄漏 requestHelper.clearSession(); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; log.info(&quot;SessionInterceptor afterCompletion方法，在整个请求结束之后调用，也就是在Dispatcher渲染了整个视图之后进行（主要进行资源清理工作）&quot;); if (Objects.nonNull(requestHelper.getSessionUser())) &#123; requestHelper.clearSession(); &#125; &#125;&#125; 可以看到实现了HandlerInterceptor接口之后，要实现其中的三个方法。 preHandle方法：在请求controller方法之前调用，这里就可以做一些session对象的校验及写入ThreadLocal方便方法调用等。只有这个方法返回true，请求才能继续下去。 postHandle方法：这个方法是在请求了controller方法之后但在视图渲染之前调用的。这里可以去做ThreadLocal中资源的清除。 afterCompletion方法：这个方法是在整个请求结束之后调用的，也就是在Dispatcher渲染整个视图之后进行的，主要进行资源清理工作。（这里也是去补偿了ThreadLocal中资源的清除）。 注册拦截器在WebMvcConfigurerAdapter的子类中注册这个拦截器。WebMvcConfigurerAdapter看名字就提供了很多springmvc关于web访问的配置。 123456789101112131415161718192021222324252627282930@Componentpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; /** * sessionInterceptor不需要拦截的请求 * 比如swagger的请求、比如一些静态资源的访问、比如错误统一处理的页面 */ private static final String[] EXCLUDE_SESSION_PATH= &#123;&#125;; @Resource private SessionInterceptor sessionInterceptor; @Resource private MyInterceptor myInterceptor; /** * 对所有的拦截器组成一个拦截器链 * addPathPatterns 用于添加拦截规则 * excludePathPatterns 用户排除拦截 * * @param registry 拦截器注册对象 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 加入自定义拦截器到 // registry.addInterceptor(myInterceptor); registry.addInterceptor(sessionInterceptor).excludePathPatterns(EXCLUDE_SESSION_PATH); super.addInterceptors(registry); &#125;&#125; 通过spring管理把自定义的拦截器注册成bean对象，然后通过register的addInterceptor方法注册到拦截器执行链中，这里也可以设置包括/过滤的访问地址等相关子属性。 我们写了个controller去测试这个自定义拦截器。其中helloService是把ThreadLocal中的对象给直接返回 1234567891011121314151617@RestControllerpublic class ThreadLocalController &#123; @Resource private HelloService helloService; /** * 在拦截器中用ThreadLocal * * @return SessionUser */ @GetMapping(value = &quot;/threadLocal/getSessionUser&quot;) public SessionUser getSessionUser() &#123; return helloService.getThreadSessionUser(); &#125;&#125; 1234@Override public SessionUser getThreadSessionUser() &#123; return requestHelper.getSessionUser(); &#125; 在浏览器中访问http://localhost:7001/threadLocal/getSessionUser 可以看到结果返回： 这说明我们的拦截器是正确将sessionUser设置进入ThreadLocal对象的。看控制台的日志输入： 多个自定义拦截器的执行顺序如果再定义一个自定义拦截器，那么执行的顺序是什么呢？ 123456789101112131415161718192021222324252627@Slf4j@Componentpublic class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; log.info(&quot;MyInterceptor preHandle方法，在请求方法之前调用，Controller方法调用之前&quot;); // 返回true才能继续执行 return true; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;MyInterceptor postHandler方法，请求处理之后调用，但是在视图被渲染之前（Controller方法调用之后）&quot;); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; log.info(&quot;MyInterceptor afterCompletion方法，在整个请求结束之后调用，也就是在Dispatcher渲染了整个视图之后进行&quot; + &quot;主要进行资源清理工作&quot;); &#125;&#125; 在webMvcConfig中注册这两个拦截器，并且在浏览器中访问同样的url。看到控制台的输入。 在webMvcConfig中，我们注册的顺序是先注册了myInterceptor，然后注册了SessionInterceptor，看到的执行顺序为： preHandle方法：myInterceptor先执行 postHandle方法：sessionInterceptor先执行 afterCompletion方法：sessionInterceptor先执行。 可见多个自定义拦截器在执行链中的执行顺序是与注册顺序相关的，preHandle方法是先注册先执行，其他两个方法是后注册的先执行。具体执行的顺序的分析可以见下图。 拦截器的缺点它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。 同时，反射也有可能对性能有些影响。 HandlerInterceptor接口分析1234567891011121314151617181920212223242526272829303132public interface HandlerInterceptor &#123; /** * preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在 * 多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在 * Controller方法调用之前调用。SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返 * 回值为false，当preHandle的返回值为false的时候整个请求就结束了。 */ boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; /** * 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 * 后，也就是在Controller的方法调用之后执行，但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操 * 作。这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，这跟Struts2里面的拦截器的执行过程有点像， * 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor * 或者是调用action，然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。 */ void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception; /** * 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， * 这个方法的主要作用是用于清理资源的，当然这个方法也只能在当前这个Interceptor的preHandle方法的返回值为true时才会执行。 */ void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; &#125; HandlerInterceptorAdapterspringMvc还提供了HandlerInterceptorAdapter这个抽象类，这个抽象类中实现了AsyncHandlerInterceptor接口，而AsyncHandlerInterceptor接口又继承了HandlerInterceptor接口，我们可以首先看下AsyncHandlerInterceptor接口： 12345678910111213141516171819public interface AsyncHandlerInterceptor extends HandlerInterceptor &#123; /** * Called instead of &#123;@code postHandle&#125; and &#123;@code afterCompletion&#125;, when * the a handler is being executed concurrently. * &lt;p&gt;Implementations may use the provided request and response but should * avoid modifying them in ways that would conflict with the concurrent * execution of the handler. A typical use of this method would be to * clean up thread-local variables. * @param request the current request * @param response the current response * @param handler the handler (or &#123;@link HandlerMethod&#125;) that started async * execution, for type and/or instance examination * @throws Exception in case of errors */ void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;&#125; 可以看到在这个接口中添加了一个afterConcurrentHandlingStarted方法。 该方法是用来处理异步请求。当Controller中有异步请求方法的时候会触发该方法。异步请求先支持preHandle、然后执行afterConcurrentHandlingStarted，之后才会执行postHandle的方法。 比如现在我们配置了一个拦截器是用来拦截异步请求的： 123456789101112131415161718192021@Component@Slf4jpublic class MyAsyncHandlerInterceptor extends HandlerInterceptorAdapter &#123; /** * 该方法是用来处理异步请求。当Controller中有异步请求方法的时候会触发该方法。 * 异步请求先支持preHandle、然后执行afterConcurrentHandlingStarted。 * * @param request * @param response * @param handler * @throws Exception */ @Override public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; super.afterConcurrentHandlingStarted(request, response, handler); log.info(&quot;MyAsyncHandlerInterceptor afterConcurrentHandlingStarted 方法执行&quot;); &#125;&#125; 这个时候我们有个异步请求处理：(对于springMvc的异步请求可以看看这篇博客：springmvc的异步请求) 123456789@RestController@Slf4jpublic class HelloController &#123; @GetMapping(value = &quot;/hello&quot;) public Callable&lt;String&gt; sayHello() &#123; return () -&gt; &quot;controller&quot;; &#125;&#125; 这时在浏览器中调用我们的异步请求，可以看到控制台中输出 可见这时先调用的是afterConcurrentHandlingStarted方法，而后调用的是postHandle方法。 我们再去看适配器HandlerInterceptorAdapter的代码： 12345678910111213141516171819202122232425262728293031323334353637383940public abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor &#123; /** * This implementation always returns &#123;@code true&#125;. */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; /** * This implementation is empty. */ @Override public void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; /** * This implementation is empty. */ @Override public void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125; /** * This implementation is empty. */ @Override public void afterConcurrentHandlingStarted( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; &#125;&#125; 可以看到preHandle方法默认实现返回了true，比如我们只想去定义一个拦截器去在方法执行完之后去释放掉一些资源，如果去实现HandlerInterceptor则显得有点麻烦。这里只要去继承这个抽象类，实现afterCompletion方法即可。 github上述代码都能在gitHub上看到：https://github.com/zhanglijun1217/spring-boot-demo]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function函数式接口的优化代码应用]]></title>
    <url>%2Fblog%2F2018%2F09%2F02%2FFunction%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言函数式接口之前就一直在接触过，之前在github上写过关于几个函数式接口简单应用的代码，但一直没有记录在工作中的应用，这次就用Function接口优化了一次重复代码的警告。关于函数式接口不熟悉的同学，可以先看下我在github上的代码工程：java8 优化记录优化前的代码数据底层提供了查询报表四个不同纬度的接口，而接口中的方法其实都是一样的：比如通过部门去查、通过部门下的人去查找报表数据，而在应用层如果去写这些查询接口的话，就是每种报表都要去查子部门和人员的数据（真实的情况更多），那么很自然的就在每种报表的实现方法中去根据查询部门还是人或者其他的可能的去进行数据的查询。 这里可以看到，这只是销售报表这一种情况，然后比如成单量、业绩额、成单率等等也是这样写的。这时候在IDEA中就会报一个警告：Duplicated Code，因为除了调用底层的接口不一样之外，其余的逻辑都是一样，并且这四个service没有去继承一个抽象类去做封装，并且这四个的返回值也不能去做抽象，并且在最后是要根据返回值的类型去进行bean转换，这时候不能简单的去根据泛型去抽象出private方法，这里想到了用函数式接口去做。 优化过程Function接口定义注意到查询底层报表数据是有的要传入两个参数的，也有的是要传入三个参数的，所以我们就需要多参数的Function接口，Java中为我们提供了BiFunction，也就是两个参数的Function接口，但是三个参数的函数式接口要我们自己定义。这里去定义一个传入三个参数和一个返回值的函数式接口。 1234567891011121314@FunctionalInterfacepublic interface TripleFunction&lt;T, U, K, R&gt; &#123; /** * Applies this function to the given arguments * * @param t the first function argument * @param u the second function argument * @param k the third function argument * @return the function result */ R apply(T t, U u, K k);&#125; 这里可以看到这个接口中有@FunctionalInterface注解和apply方法。 查询报表逻辑处理这里去写一个查询报表的通用逻辑处理。首先看参数，condition是传入的筛选条件，clazz是返回值泛型R的class，queryUserFun是传入两个参数的计算出T的的函数，同样queryDeptByIdFunc是传入两个参数，计算出PlainResult的函数式参数。剩下两个函数参数是传入三个参数计算出ListResult参数。 这里为什么要去传R、T两个泛型？因为这里直接调用rpc接口返回的结果是他们封装的一个DTO对象，我们要自爱应用层自己运用orika工具进行DTO的转换（防污染和降低耦合）。那为什么要单独去传入一个最后返回值得class对象？这里是因为泛型在运行时会被擦除，要使用orika去转换DTO时要进行class的参数传入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 查询报表的方法 * * @param condition 筛选条件 * @param clazz 结果class * @param queryUserFunc 查询user函数 * @param queryUsersFunc 查询users函数 * @param queryDeptFunc 查询dept函数 * @param &lt;T&gt; 泛型1 * @param &lt;R&gt; 泛型2 * @return */ private &lt;T, R&gt; Pagination&lt;R&gt; getReport(AchievementPkDTO condition, Class&lt;R&gt; clazz, BiFunction&lt;Long, DateRangeDTO, ListResult&lt;T&gt;&gt; queryUserFunc, BiFunction&lt;Long, DateRangeDTO, PlainResult&lt;T&gt;&gt; queryDeptByIdFunc, TripleFunction&lt;Long, DateRangeDTO, OrderAndPageDTO, ListResult&lt;T&gt;&gt; queryUsersFunc, TripleFunction&lt;Long, DateRangeDTO, OrderAndPageDTO, ListResult&lt;T&gt;&gt; queryDeptFunc) &#123; DateRangeDTO dateRangeDTO = convertDateRangeDTO(condition); OrderAndPageDTO orderAndPageDTO = convertOrderAndPageDTO(condition); // 初始化 ListResult&lt;T&gt; result = new ListResult&lt;&gt;(); // 如果是有赞部门节点 if (OrganizationType.YOUZAN_SUB_DEPARTMENTS.equals(condition.getOrganizationType())) &#123; result = queryDeptFunc.apply(condition.getOrganizationId(), dateRangeDTO, orderAndPageDTO); &#125; else if (OrganizationType.YOUZAN_USER.equals(condition.getOrganizationType())) &#123; // 人的节点 result = queryUserFunc.apply(condition.getOrganizationId(), dateRangeDTO); &#125; else if (OrganizationType.YOUZAN_DEPARTMENT_USERS.equals(condition.getOrganizationType())) &#123; // 部门人的节点 result = queryUsersFunc.apply(condition.getOrganizationId(), dateRangeDTO, orderAndPageDTO); &#125; else if (OrganizationType.SINGLE_PROVIDER.equals(condition.getOrganizationType())) &#123; // 单个渠道商节点 PlainResult&lt;T&gt; apply = queryDeptByIdFunc.apply(condition.getOrganizationId(), dateRangeDTO); // 设置result信息 result.setData(Collections.singletonList(CheckWrapper.checkWrap(apply))); result.setCount(1); result.setSuccess(true); &#125; List&lt;R&gt; rList = orikaBeanUtil.convertList(CheckWrapper.checkWrap(result), clazz); return new Pagination&lt;&gt;(rList, condition.getPage(), condition.getPageSize(), result.getCount()); &#125; 实现不同种报表的查询有了上述通过Function接口的改造，使得不同的业务场景（业绩、成单量等）都可以传入一个lambda表达式去调用上边封装的获取参数的方法。比如下面的这两个方法（这样并不会报Duplicated Code警告）： 12345678910111213141516171819202122232425262728293031@Override public Pagination&lt;DealAmountStatistics&gt; getDealReport(AchievementPkDTO condition) &#123; if (Objects.equals(OrganizationType.PROVIDER, condition.getOrganizationType())) &#123; return doWithDealProvider(condition); &#125; else &#123; return getReport(condition, DealAmountStatistics.class, (organizationId, date) -&gt; dealAmountStatisticsService.getUserById(organizationId, date), (organizationId, date) -&gt; dealAmountStatisticsService.getDepartmentById(organizationId, date), (organizationId, date, range) -&gt; dealAmountStatisticsService.getUsersByDepartmentId(organizationId, date, range), (organizationId, date, range) -&gt; dealAmountStatisticsService.getDepartmentsByParentId(organizationId, date, range)); &#125; &#125; @Override public Pagination&lt;OrderNumStatistics&gt; getOrderNumberReport(AchievementPkDTO condition) &#123; if (Objects.equals(OrganizationType.PROVIDER, condition.getOrganizationType())) &#123; return doWithOrderNumProvider(condition); &#125; else &#123; return getReport(condition, OrderNumStatistics.class, (organizationId, date) -&gt; orderNumStatisticsService.getUserById(organizationId, date), (organizationId, date) -&gt; orderNumStatisticsService.getDepartmentById(organizationId, date), (organizationId, date, range) -&gt; orderNumStatisticsService.getUsersByDepartmentId(organizationId, date, range), (organizationId, date, range) -&gt; orderNumStatisticsService.getDepartmentsByParentId(organizationId, date, range)); &#125; &#125; 这里去因为PROVIDER类型节点要对不同的返回值做特殊处理，否则这两个方法还可以抽象成为一个公用方法，这里不去对抽象过多要求，主要想记录学习的是用函数式接口去优化代码减少了代码重复行数，并且lambda表达式作为参数的一个使用也没有降低可读性。之后在写代码的过程中可以多应用这种设计，去让代码变得更加简洁，使用更多的新特性。]]></content>
      <categories>
        <category>Java语法</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>函数式接口</tag>
        <tag>代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次freemarker错误排查]]></title>
    <url>%2Fblog%2F2018%2F08%2F29%2F%E8%AE%B0%E4%B8%80%E6%AC%A1freemarker%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[前言在最近的工作中遇到了一个做一个导出功能时遇到了一个很奇怪的事情，逻辑是先做一个export方法上传到文件服务器上，然后重定向到一个doExport方法中，这个doExport方法中是去判断这个文件是否生成（之前生成Excel文件是异步线程生成的），如果没有生成，则转到一个export.ftl的freemarker页面，这个页面中去不断reload去调用这个doExport方法，直到导出了文件。但是在本地测试的时候，总发现doExport方法会无限的将请求再转发到export方法中，然后就一直产生了无限重定向，在浏览器中会有报无限重定向而给拦截掉。 现象两个controller： 模板文件： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;报表导出&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot; border:1px solid #ccc; margin:200px auto; height:70px;background:#eee;padding:40px;color:green;text-align:center;&quot;&gt;正在生成报表，请耐心等待...&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; setTimeout(&quot;location.reload()&quot;, 1000);&lt;/script&gt;、&lt;/body&gt;&lt;/html&gt; 本地开启debug模式进行调试： 可以看到现在是线程nio-7001-exec-1去发送到重定向到下边的doExport方法 此时在doExport中是新的exec-2线程去调用这个方法判断文件是否存在 同样的是这个线程去返回modelAndView，按理说这时候应该返回模板类freemarker中的export.ftl，但是它没有去返回freemarker文件，而是将这个请求转发到了export方法： 而且是同一个线程，是容器内跳转。之后因为每次export方法都会去生成一个新的随机的文件名称，所以又会去调用doExport方法去下载新的文件名称的文件，直到有一个个文件内容比较少，异步线程在判断文件是否存在之前，文件导出，否则浏览器会直接拦截这么多次的重定向： 排查过程是不是freemarker的文件路径配置有问题既然是容器内跳转，而没有访问到真正的导出页面的文件，那是不是freemarker的文件访问路径配置有问题。看到本地环境的properties文件中关于freemarker配置如下： 12345678# freemarker相关配置spring.freemarker.enabled=truespring.freemarker.suffix=.ftlspring.freemarker.content-type=text/htmlspring.freemarker.cache=falsespring.freemarker.charset=utf-8spring.freemarker.check-template-location=truespring.freemarker.template-loader-path=classpath:/templates/ 这里去查看了模板文件确实是放在了classpath下的templates文件夹中的。所以配置和访问文件的路径没有问题。 是不是因为mapping重名，优先映射到了mapping地址这里发现模板文件的名称和export的mapping地址是一样的，则在exprot方法上加了一个1,saleDetail/exprot1这样，然后再次debug发现，这时候不会再重新容器内跳转到这个方法，但是页面直接报了404错误，这说明还是没有去加载到模板文件。 进行一个简答的路由到模板文件的测试这时候去写了一个helloController，然后在templetes下新建了一个hello.ftl模板文件，在controller中去return modelAndView，这时视图也是hello，发现也是404的错误。这说明和sendRedirect方法也没有关系，本身项目是不支持freemarker的。 最后发现在整个项目中，都没有freemarker的依赖和jar包。。。加入freemarker的依赖之后问题解决。 因为mapping地址和freemarker的模板文件地址相同，在你返回modelAndView的视图名称在mapping中找的到时，springmvc会容器内跳转，也不会报freemarker模板文件找不到的错误。因为其他工程也是这样去写的，所以就想当然的以为这个工程中也会有freemarker依赖。其实这个时候应该跟一下spring mvc的源码，就可以看到这时候跳转的是dispatcherServlet路由到的export方法，并没有走freemarker的模板文件。这里去记录一下。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot actuator]]></title>
    <url>%2Fblog%2F2018%2F08%2F25%2Fspring-boot-actutor%2F</url>
    <content type="text"><![CDATA[前言spring boot的一大特性就是自带的actuator。它是spring-boot框架提供的对应系统的自省和监控的集成功能，可以对系统进行配置查看、相关功能统计等。 actuator的使用引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件的配置 management.port:指定访问监控防范的端口，这个端口应该与逻辑端口分离。如果不想使actuator暴露在http中，可以设置这个端口为-1。 management.address：指定地址，比如只能通过本机监控，可以设置 management.address = 127.0.0.1启动项目，可以看到actuator启动在了配置的7002端口，并且提供了可以访问其中的一些endPoints。 一些主要的EndPointsspring-boot提供了一些常用的EndPoints其中鉴权为true的表示访问这些endPoints是需要保护的不能随意进行访问的。如果要取消，可以设置关闭鉴权（低版本的spring-boot没有提供鉴权）1management.security.enable=false 官方文档可以看到这个监控和自省的功能是十分有用的，可以看到bean信息、dump信息、mapping信息和访问链路信息等，所以这个功能在官方文档中也说的很清楚，我们也可以通过实现HealthIndicator接口，编写自己的health接口，也可以增加自己的监控接口。具体的还可以看一下官方文档 acautor文档]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>actuator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[validate注解做校验]]></title>
    <url>%2Fblog%2F2018%2F08%2F18%2Fvalidate%E6%B3%A8%E8%A7%A3%E5%81%9A%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[前言之前也用过hibernate的校验注解，但是没有去做一个总结，这里参考一篇博客去做一个总结。简述JSR303/JSR-349，hibernate validation，spring validation之间的关系。JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。而hibernate validation是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。而万能的spring为了给开发者提供便捷，对hibernate validation进行了二次封装，显示校验validated bean时，你可以使用spring validation或者hibernate validation，而spring validation另一个特性，便是其在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中。这无疑便捷了我们的web开发。本文主要介绍在springmvc中自动校验的机制。 引入依赖因为我们构建的是spring boot项目，所以直接引入web的starter的依赖即可。123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果查看其子依赖，可以发现如下的依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; 进行校验校验的实体类这里用了lombok的@Data注解，也是非常推荐大家使用的一个插件。12345678910111213141516171819202122232425@Datapublic class ValidateBO &#123; @NotBlank(message = &quot;name不能为空&quot;) private String name; @Min(value = 18, message = &quot;年龄不能小于18岁&quot;) private Integer age; @Email(message = &quot;email格式错误&quot;) private String email; /** * 自定义注解 不能包含空格字符串 */ @CannotHaveBlank private String blank; /** * 正则校验 */ @Pattern(regexp = &quot;^1(3|4|5|7|8)\\d&#123;9&#125;$&quot;, message = &quot;手机号码格式错误&quot;) private String phone;&#125; 可以看到这里用到了一些常见的注解。（自定义校验注解在下边会提到） controller进行校验在controller中进行这个字段的校验，可以看到每个需要校验的对象，都需要一个BindingResult去承接校验的结果，并且也要对要校验的类去加上@Validated注解。123456789101112@GetMapping(value = &quot;/validate&quot;) public String validate(ValidateBO validateBO, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; StringBuilder stringBuilder = new StringBuilder(); for (String s : bindingResult.getFieldErrors().stream() .map(FieldError::getDefaultMessage).collect(Collectors.toList())) &#123; stringBuilder.append(s); &#125; return stringBuilder.toString(); &#125; return &quot;success&quot;; &#125; 启动项目，在url中输入对项目进行debug。可以看到，校验在碰到第一个字段不符合要求之后，并不是直接返回错误，而是会对所有的要校验字段去校验。当然这个也是可以配置的，下边会提到fast-fail的配置。最后返回的结果：这里是打印出了这个对象中所有的错误。 常见的校验注解JSR提供的校验注解:12345678910111213@Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator提供的校验注解：12345@NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 分组校验场景如果同一个类，在不同的使用场景下有不同的校验规则，那么可以使用分组校验。未成年人是不能喝酒的，而在其他场景下我们不做特殊的限制，这个需求如何体现同一个实体，不同的校验规则呢？ 校验对象12345678910111213@Datapublic class ValidateByGroupBO &#123; /** * 只有adult组内才进行 validate 校验 */ @Min(value = 18, groups = &#123;Adult.class&#125;) private Integer age; public interface Adult&#123;&#125; public interface Minor&#123;&#125;&#125; 这就定义了只有在在adult组内才会进行最小值18的校验。 进行验证1234567891011121314151617181920212223242526272829/** * 喝酒这个去校验了年龄值，因为只有adult这个组才去校验年龄 * @param validateByGroupBO * @param bindingResult * @return */ @GetMapping(value = &quot;/drink&quot;) public String drink(@Validated(&#123;ValidateByGroupBO.Adult.class&#125;) ValidateByGroupBO validateByGroupBO, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; // 处理错误 return &quot;false&quot;; &#125; return &quot;success&quot;; &#125; /** * 生活不需要去校验adult的分组 就不去校验对应的age的最小值 * @param validateByGroupBO * @param bindingResult * @return */ @GetMapping(value = &quot;live&quot;) public String live(@Validated ValidateByGroupBO validateByGroupBO, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; // 错误处理 return &quot;false&quot;; &#125; return &quot;success&quot;; &#125; 运行之后，在url中输入http://localhost:7001/drink?age=10，第一个返回false，因为指定了使用其中的Adult分组，会开启对age的校验。输入http://localhost:7001/live?age=10则会不去校验age的大小，返回success。喝酒要校验是否成年，而生活不用，类似的场景还是很容易碰到的。 自定义注解实现一个注解这里去实现一个字符串中不能含有blank空格。主要分为两步： 先去定义这个注解，其中validatedBy指定的是真正去做校验的实体类。而其中的groups和payload可以直接用默认。 123456789101112131415161718192021222324@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, ElementType.CONSTRUCTOR, PARAMETER&#125;)@Retention(RUNTIME)@Documented// 这个注解是引入真正的去做验证的类@Constraint(validatedBy = &#123;CannotHaveBlankValidator.class&#125;)public @interface CannotHaveBlank &#123; // 默认错误信息 String message() default &quot;不能包含空格&quot;; // 分组 Class&lt;?&gt;[] groups() default &#123;&#125;; //负载 Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; //指定多个时使用 @Target(&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;) @Retention(RUNTIME) @Documented @interface List &#123; CannotHaveBlank[] value(); &#125;&#125; 第二步是去实现真正去做校验的实体类 12345678910111213141516171819202122232425public class CannotHaveBlankValidator implements ConstraintValidator&lt;CannotHaveBlank, String&gt; &#123; @Override public void initialize(CannotHaveBlank cannotHaveBlank) &#123; &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //null时不进行校验 if (value != null &amp;&amp; value.contains(&quot; &quot;)) &#123; //获取默认提示信息 String defaultConstraintMessageTemplate = context.getDefaultConstraintMessageTemplate(); System.out.println(&quot;default message :&quot; + defaultConstraintMessageTemplate); //禁用默认提示信息 context.disableDefaultConstraintViolation(); //设置提示语 context.buildConstraintViolationWithTemplate(&quot;can not contains blank&quot;) .addConstraintViolation(); return false; &#125; return true; &#125;&#125; 这里去实现类去实现了ConstraintValidator接口，这个接口中包含一个初始化事件方法和一个判断是否合法的方法：123456789package javax.validation;import java.lang.annotation.Annotation;public interface ConstraintValidator&lt;A extends Annotation, T&gt; &#123; void initialize(A var1); boolean isValid(T var1, ConstraintValidatorContext var2);&#125; 其中的A泛型参数是上一步定义的注解类，泛型T是要去校验的字段类型。ConstraintValidatorContext 这个参数上下文包含了认证中所有的信息，我们可以利用这个上下文实现获取默认错误提示信息，禁用错误提示信息，改写错误提示信息等操作。 自定义注解进行校验还是用第一个controller去验证这个自定义注解。因为要校验的对象中加入了自定义注解的blank字段。启动项目，输入http://localhost:7001/validate?blank=19 209（这里加了空格），可以看到返回值是：说明自定义注解起到了作用。 @Valid 和 @Validated的区别https://blog.csdn.net/qq_27680317/article/details/79970590这篇讲的很清晰了。 aop很显然，如果我们每个controller中的方法都去写BindingResult就显得很麻烦了，其实我们就是要对参数进行校验并且输出到log中，这就很自然的想到了aop。 注解标识定义一个注解去标识使用了hibernate validate注解123456789101112131415161718192021package com.zhanglijun.springbootdemo.domain.anno;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.validation.groups.Default;/** * 用来表示开启hibernate校验的注解 * @author 夸克 * @create 2018/8/19 22:28 */@Target(&#123;ElementType.METHOD,ElementType.TYPE,ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface EnableValidate &#123; Class&lt;?&gt; [] groups() default &#123; Default.class &#125;;//校验分组信息&#125; 定义切面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162package com.zhanglijun.springbootdemo.aspect;import com.zhanglijun.springbootdemo.domain.anno.EnableValidate;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import java.util.HashSet;import java.util.Set;import javax.validation.ConstraintViolation;import javax.validation.ConstraintViolationException;import javax.validation.Validation;import javax.validation.Validator;import javax.validation.executable.ExecutableValidator;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.hibernate.validator.HibernateValidator;import org.springframework.core.annotation.AnnotationUtils;import org.springframework.stereotype.Component;import org.springframework.util.ClassUtils;/** * @author 夸克 * @create 2018/8/19 18:45 */@Slf4j@Aspect@Componentpublic class ValidatorAspect &#123; /** * 获取校验的工厂的信息 */ private static final Validator validator = Validation.byProvider(HibernateValidator.class) .configure() //快速失败模式开启，当检测到有一项失败立即停止 .failFast(true) .buildValidatorFactory().getValidator(); /** * point配置 */ @Pointcut(&quot;execution(* com.zhanglijun.springbootdemo.web.controller..*.*(..))&quot;) public void pointcut() &#123; &#125; /** * @desction: 校验步骤 1.首先校验是否含有基本的Hibernate validator 注解，有异常抛出 2.校验方法参数中是否含有EgValidate注解，获取分组信息，进行Bean级别的校验，有异常抛出 * 3.查看当前的方法中（优先级高）(或者父类、父接口)是否含有EgValidate注解，没有获取当前类的中是否是否含有EgValidate注解，获取分组信息，针对每一个非基本类型Bean进行校验，有异常掏出 * @author: wangji * @date: 2018/3/13 10:16 */ @Before(&quot;pointcut()&quot;) public void before(JoinPoint point) &#123; // 获得切入目标对象 Object target = point.getThis(); // 获得切入方法参数 Object[] args = point.getArgs(); // 获得切入的方法 Method method = ((MethodSignature) point.getSignature()).getMethod(); Annotation[] classAnnotations = target.getClass().getAnnotations(); Annotation[] methodAnnotations = method.getAnnotations(); Annotation[][] parameterAnnotations = method.getParameterAnnotations(); //如果方法参数有基本的注解，就进行Hibernate validator 基本的参数校验 if (parameterAnnotations != null) &#123; validMethodParams(target, method, args); &#125; // 判断参数中是否含有EgValidate注解，进行特殊分组，Bean级别的参数校验 int i = 0; //排查掉已经在参数中校验过的参数不适用类或者方法上的校验参数在次进行校验 Set&lt;Integer&gt; idSet = new HashSet&lt;&gt;(3); for (Object arg : args) &#123; if (arg != null) &#123; if (parameterAnnotations != null) &#123; for (Annotation parameterAnnotation : parameterAnnotations[i]) &#123; if (parameterAnnotation instanceof EnableValidate) &#123; if (!ClassUtils.isPrimitiveOrWrapper(arg.getClass())) &#123; validBeanParam(arg, ((EnableValidate) parameterAnnotation).groups()); idSet.add(i); &#125; &#125; &#125; &#125; i++; &#125; &#125; // 如果没有异常继续校验当前的每一个非基本类型的参数 EnableValidate egValidate = null; //方法上是否有校验参数 if (methodAnnotations != null) &#123; egValidate = AnnotationUtils.findAnnotation(method, EnableValidate.class); &#125; // 类上是否含有 if (egValidate == null &amp;&amp; classAnnotations != null) &#123; egValidate = AnnotationUtils.findAnnotation(target.getClass(), EnableValidate.class); &#125; // 如果在类或者方法上加了验证注解 ，则对所有非基本类型的参数对象进行验证,不管参数对象有没有加注解，使用方法上的分组 if (egValidate != null &amp;&amp; args != null &amp;&amp; args.length &gt; 0) &#123; i = 0; for (Object arg : args) &#123; if (arg != null &amp;&amp; !ClassUtils.isPrimitiveOrWrapper(arg.getClass()) &amp;&amp; !idSet .contains(i)) &#123; validBeanParam(arg, egValidate.groups()); &#125; i++; &#125; &#125; &#125; /** * @param obj 参数中的Bean类型参数 * @param groups 分组信息 * @desction: 进行参数中的Bean校验 * @author: wangji * @date: 2018/3/13 10:10 */ private void validBeanParam(Object obj, Class&lt;?&gt;... groups) &#123; Set&lt;ConstraintViolation&lt;Object&gt;&gt; validResult = validator.validate(obj, groups); throwConstraintViolationException(validResult); &#125; /** * @param obj 当前的实例 * @param method 实例的方法 * @param params 参数 * @desction: 对于Hibernate 基本校验Bean放在参数中的情况的校验 【例如 User getUserInfoById(@NotNull(message = * &quot;不能为空&quot;) Integer id);】 * @author: wangji * @date: 2018/3/13 10:11 */ private void validMethodParams(Object obj, Method method, Object[] params) &#123; ExecutableValidator validatorParam = validator.forExecutables(); Set&lt;ConstraintViolation&lt;Object&gt;&gt; validResult = validatorParam .validateParameters(obj, method, params); throwConstraintViolationException(validResult); &#125; /** * @desction: 判断校验的结果是否存在异常 * @author: wangji * @date: 2018/3/13 10:09 */ private void throwConstraintViolationException(Set&lt;ConstraintViolation&lt;Object&gt;&gt; validResult) &#123; if (!validResult.isEmpty()) &#123; throw new ConstraintViolationException(validResult.iterator().next().getMessage(), validResult); &#125; &#125;&#125; 这个切面说的也很清除，对多处使用这个的地方都去做了一个校验。 github上述代码都在我的github，可以在review一下代码。validated注解相关 引用参考的博客： https://www.cnkirito.moe/spring-validation/ https://blog.csdn.net/oKuZuoZhou/article/details/81024795 https://blog.csdn.net/u012881904/article/details/79538895]]></content>
      <categories>
        <category>spring</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>validate注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——ThreadLocal总结]]></title>
    <url>%2Fblog%2F2018%2F08%2F16%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94ThreadLocal%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概念介绍ThreadLocal是早期jdk版本中就有的一个工具，基本原理是同一个ThreadLocal所包含的对象（对ThreadLocal而言即为String类型变量），在不同的Thread中有不同的副本（实际是不同的实例）。这里有几点需要注意： 因为每个Thread内有自己的实例副本，且该副本只能由当前的Thread使用。这也是ThreadLocal命名的由来。 既然每个Thread都有自己的实例副本，且其他的Thread不可访问，那么就不存在多线程共享的问题（其实ThreadLocal也不是去解决多线程共享的问题）。 那么ThreadLocal解决了什么问题呢？ThreadLocal提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal变量通常被private static修饰。当一个线程结束时，它所使用的ThreadLocal相对的实例副本都可被回收。 ThreadLocal的适用场景：ThreadLocal适用于每个线程需要自己独立的实例且该实例需要在多个方法中使用，也即变量在线程间隔离而在方法或类间共享的场景。其实这种场景下并不只是可以用ThreadLocal去解决，只不过ThreadLocal更简洁。 ThreadLocal原理实现可能的猜想ThreadLocal维护线程与实例的映射 既然每个访问ThreadLocal变量的线程都有自己的一个“本地”实例副本，那么可能的方案是ThreadLocal维护着一个Map，键是Thread，值是它在这个Thread中的实例。线程通过该ThreadLocal的get()方法获取实例时，只需要以线程为键，从map中获取实例即可。 这个方案却又有问题： 增加线程和减少线程都需要去put、remove操作map,这个时候如果在一个ThreadLocal对该线程存入两个实例，就会有线程安全问题、 线程结束时，需要保证它所访问的所有的ThreadLocal中的对应的映射均删除，否则可能会引起内存泄漏。 第一个问题是jdk不去采取这种做法的原因。 ThreadLocal维护ThreadLocal与实例的映射 如果这个Map是每个线程去访问自己的一个Map，就不会产生多线程写的问题。map中维护着key为ThreadLocal实例，设计如下图所示。 这个方案中解决了map的线程安全问题，相当于第一种方法的倒转想法，map中key设置为ThreadLocal实例在不同线程中访问。 这种方案还是没有去解决内存泄漏问题。由于每个线程访问到ThreadLocal变量之后，都会在自己的Map内维护该ThreadLocal变量与具体实例的映射，如果不删除这些引用（映射），则这些ThreadLocal不能被回收，可能会造成内存泄漏。 JDK中的解决ThreadLocalMap 上边提到的维护的map是由ThreadLocal中的静态内部类ThreadLcoalMap去提供的，该类的实例维护着某个ThreadLocal与具体实例的映射。与HashMap不同的是，每个ThreadLocalMap的每一个Entry都是一个对键的弱引用，这一点可以从super(k)可以看出。每一个Entry对key的引用是强引用。使用ThreadLocal弱引用的原因是可以被及时回收。但是这里不能解决Entry引用内存泄漏的问题。当ThreadLocal变量被回收之后，该映射的键值变为null，该Entry无法被移除。从而也有可能造成内存泄漏。（下面会提到JDK的解决）ThreadLocalMap中的Entry代码如下：12345678static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 读取实例12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 读取实例时，线程首先通过getMap(t)方法获取自身的ThreadLocalMap。获取到ThreadLocalMap后，通过map.getEntity(this)方法获取该ThreadLocal在当前线程的ThreadLocalMap中的Entry。该方法中的this即当前访问的ThreadLocal方法。如果获取到的Entry不为null，从Entry中取出值即为所需访问的本线程对应的实例。如果获取到的Entry为null，则通过setInitialValue()方法设置该ThreadLocal变量在该线程中对应的具体实例的初始值。设置初始值的方法如下： 12345678910private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 注意此方法为private方法，无法被重载。 首先，通过initialValue()方法能生成一个初始值，这个方法是一个public方法，且默认值为null。所以典型用法中常常去重载该方法去给一个默认值。然后，通过当前线程对象拿到ThreadLocalMap对象，若该对象不为null，则直接塞入map中set进去线程内实例的值。如果map为null，则去创建该ThreadLcoalMap对象。 设置实例。 设置实例的方法也是采用了上述方法中的原理，不多做解释了。12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 防止内存泄漏 对于已经不再使用且已被回收的ThreadLocal对象，它在每个线程内对应的实例由于被线程的TheradLcoalMap的Entry强引用，无法被回收，可能会造成内存泄漏。 针对该问题，ThreadLocal的set方法中去做了处理。replaceStaleEntry方法将所有键为null 的Entry的值设置为null，从而使得该值可被回收。另外，会在rehash方法中通过 expungeStaleEntry 方法将键和值为null的Entry设置为null从而使得该 Entry可被回收。通过这种方式，ThreadLocal可防止内存泄漏。 1234567891011121314151617181920private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; ThreadLocal的适用场景 每个线程需要自己有单独的实例 实例需要在对个方法中共享，但不希望被多线程共享。 Threadlocal一个工具类总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * threadLocal工具类 * @author 夸克 * @create 2018/8/15 16:47 */public class ThreadLocalUtil &#123; /** * 不同的业务区分ThreadLocal中map的key * （这里的map不是threadLocal中对应线程的threadLocalMap，而是要塞入线程中的map的值， * 这里可能在一个业务域中一个线程存在多次使用ThreadLocal，所以在threadLocal中塞入的是个map。而 * 当前线程中存放的是&lt;threadLocal对象,&lt;业务key, 真正要使用的变量&gt;&gt;） * threadLocal内存泄漏问题（（1）ThreadLocalMap中Entry的引用没有释放）在jdk8中得到了解决， * 对ThreadLocalMap中的键值threadLocal实例的引用改为弱引用 * 所以建议使用ThreadLocal */ /** * 业务前缀key值的维护 */ public enum Key &#123; /** * 测试使用 */ COMMON_TEST(&quot;COMMON_TEST&quot;); private String key; Key(String key) &#123; this.key = key; &#125; &#125; private static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;(); /** * set方法 * @param key * @param value */ public static void set(String key, Object value) &#123; if(THREAD_LOCAL.get() == null) &#123; // 初始化 init(); &#125; if (StringUtils.isEmpty(key) || Objects.isNull(value)) &#123; return; &#125; THREAD_LOCAL.get().put(key, value); &#125; /** * get方法 * @param key * @return */ public static Object get(String key) &#123; if (StringUtils.isEmpty(key)) &#123; return null; &#125; return THREAD_LOCAL.get().get(key); &#125; /** * 刷新方法 */ public static void refresh() &#123; if (THREAD_LOCAL.get() == null) &#123; return; &#125; // map清除 key value THREAD_LOCAL.get().clear(); // 清除map THREAD_LOCAL.set(null); // 线程中ThreadLocalMap remove THREAD_LOCAL.remove(); &#125; private static void init() &#123; THREAD_LOCAL.set(Maps.newHashMap()); &#125;]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发工具</category>
      </categories>
      <tags>
        <tag>ThreadLcoal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring中根据Application获取BEAN的工具类]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2Fspring%E4%B8%AD%E6%A0%B9%E6%8D%AEApplication%E8%8E%B7%E5%8F%96BEAN%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[背景 在最近的开发工作中，用到了策略模式（之前也写过关于策略模式这个设计模式的学习，但是之前那个不是在spring框架中），这时候策略中的context或者factory就要去动态的根据调用的策略类型不同去拿到对应的bean对象，这里去了解了一个通过application context拿取bean的工具类，这里记录一下。 话不多说，直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Component@Slf4jpublic class ApplicationContextBeanUtil implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; /** * 利用aware注入application * @param applicationContext * @throws BeansException */ @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; // 注入application ApplicationContextBeanUtil.applicationContext = applicationContext; &#125; private static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; /** * 通过name获取bean * @param name * @return */ public static Object getBean(String name) &#123; return getApplicationContext().getBean(name); &#125; /** * 通过class获取bean * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(clazz); &#125; /** * 通过name和class获取bean * @param name * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(name, clazz); &#125; /** * 根据clazz类型获取spring容器中的对象 * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBeansOfType(clazz); &#125; /** * 根据注解类从容器中获取对象 * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; Map&lt;String, Object&gt; getBeansOfAnnotation(Class&lt;? extends Annotation&gt; clazz) &#123; return getApplicationContext().getBeansWithAnnotation(clazz); &#125;&#125; 这是通过实现ApplicationContextAware接口去实现注入application的，这里应该注意几点： application应该是静态的。这个Util类应该是在别的类中直接调用获取bean的静态方法，所以注入的applicationContext应该都是该类的静态变量。 要用注解或者在xml文件中将这个Util配置成bean。（这里用的spring boot，就直接配置的扫描）。 在其中提供了一些获取bean的方法。 这里去记录下，方便在之后的工作中遇到了之后去直接使用]]></content>
      <categories>
        <category>spring</category>
        <category>框架应用</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8中list转map方法总结]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2FJava8%E4%B8%ADlist%E8%BD%ACmap%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景 在最近的工作开发之中，慢慢习惯了很多Java8中的Stream的用法，很方便而且也可以并行的去执行这个流，这边去写一下昨天遇到的一个list转map的场景。 list转map在Java8中stream的应用常用方式1.利用Collectors.toMap方法进行转换123public Map&lt;Long, String&gt; getIdNameMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getId, Account::getUsername));&#125; 其中第一个参数就是可以，第二个参数就是value的值。 2.收集对象实体本身 在开发过程中我们也需要有时候对自己的list中的实体按照其中的一个字段进行分组（比如 id -&gt;List），这时候要设置map的value值是实体本身。123public Map&lt;Long, Account&gt; getIdAccountMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getId, account -&gt; account));&#125; account -&gt; account是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法 Function.identity()，这个方法返回自身对象，更加简洁 重复key的情况。 在list转为map时，作为key的值有可能重复，这时候流的处理会抛出个异常：Java.lang.IllegalStateException:Duplicate key。这时候就要在toMap方法中指定当key冲突时key的选择。(这里是选择第二个key覆盖第一个key)123public Map&lt;String, Account&gt; getNameAccountMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getUsername, Function.identity(), (key1, key2) -&gt; key2));&#125; 用groupingBy 或者 partitioningBy进行分组 根据一个字段或者属性分组也可以直接用groupingBy方法，很方便。 12345678Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());&#125; partitioningBy可以理解为特殊的groupingBy，key值为true和false，当然此时方法中的参数为一个判断语句（用于判断的函数式接口） 12345Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println(&quot;Children number: &quot; + children.get(true).size());System.out.println(&quot;Adult number: &quot; + children.get(false).size()); 关于stream使用的好文推荐： 这里去看了ibm的一篇关于stream的文章，get到了不少stream还没遇到过的用法。老铁们可以去学习一下。[https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/ ]]]></content>
      <categories>
        <category>Java语法</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——CopyOnWrite容器]]></title>
    <url>%2Fblog%2F2018%2F08%2F04%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94CopyOnWrite%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。 什么是CopyOnWrite容器从字面意思上看是写时复制的容器。通俗理解就是我们往一个容器中添加元素时，不直接往容器中添加，而是先将容器copy，复制出一个新的容器，然后新的容器里添加元素，添加完新的元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，但不需要加锁，因为当前在读的容器中不会添加新的元素，运用一种读写分离容器的思想。 copyOnWriteArrayList实现原理来看几个方法（1）add (E e)这里是要加锁的，因为在add的时候是要Arrays.copyOf出一个容器副本的，如果多线程访问会造成copy多个容器副本出来。可以看到是在copy完成添加元素之后去将引用指向这个新的数组。1234567891011121314151617181920/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; （2）get(int index)读的时候并没有加锁，如果读的时候有线程同时去添加元素，还是会读到之前的旧的容器，所以并不用加速，但要求对读的数据一致性没那么高。123456789/** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; return get(getArray(), index);&#125; 应用场景 copyOnWrite并发容器用于读多写少的并发场景。比如白名单、黑名单、商品类目等。比如有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单每晚会更新一次。当用户搜索时，会检查关键字在不在黑名单中，如果在，则提示不能搜索。 另外迭代操作远远大于修改操作时，才应该使用“写入时复制”容器。这个准则很好的描述了许多事件通知系统：在分发通知时需要迭代已注册监听器链表，并调用每个监听器，在大多数情况下，注册和注销事件监听器的操作远少于接受事件通知的操作。 copyOnWriteArrayList用于替代同步list，在某些情况下它提供了更好的并发性能，并且能在迭代期间不需要对容器进行加锁或者复制。 实现一个copyOnWriteMap容器 简单根据“写入时复制”的思想实现一个map容器，并做简单测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package collection;import java.util.AbstractMap;import java.util.HashMap;import java.util.Map;import java.util.Set;/** * 简单根据CopyOnWrite容器的思想去实现一个map 只实现了get put putAll方法 且一些临界异常条件没有去处理 * * @author 夸克 * @create 2018/7/8 15:58 */public class CopyOnWriteMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable &#123; private volatile Map&lt;K, V&gt; internalMap; public CopyOnWriteMap() &#123; internalMap = new HashMap&lt;&gt;(); &#125; /** * 此方法未实现 */ @Override public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123; return null; &#125; @Override public V get(Object key) &#123; // 读时不加锁 return internalMap.get(key); &#125; @Override public V put(K key, V value) &#123; // 写时复制加锁 synchronized (this) &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap); V val = newMap.put(key, value); internalMap = newMap; return val; &#125; &#125; @Override public void putAll(Map&lt;? extends K, ? extends V&gt; data) &#123; synchronized (this) &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;&gt;(internalMap); newMap.putAll(data); internalMap = newMap; &#125; &#125; public static void main(String[] args) &#123; CopyOnWriteMap&lt;Integer, Integer&gt; copyOnWriteMap = new CopyOnWriteMap(); // 初始化数据 Map&lt;Integer, Integer&gt; map = new HashMap(); for (int i = 0; i &lt; 10; i++) &#123; map.put(i, i); &#125; // 读五次线程 for (int i = 0; i &lt; 5; i++) &#123; Thread read = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 方便写线程写入数据 如果不加sleep 是读不到数据的，因为是在新复制的容器中写。 // 测试copyOnWrite思想 Thread.sleep(500); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(copyOnWriteMap.get(5)); &#125; &#125;); read.start(); &#125; // 写线程 Thread write = new Thread(new Runnable() &#123; @Override public void run() &#123; map.forEach((k, v) -&gt; &#123; copyOnWriteMap.put(k, v); &#125;); &#125; &#125;); write.start(); &#125;&#125; 代码地址https://github.com/zhanglijun1217/juc 缺点 显然，每次修改容器的时候都会复制底层数组，这回造成一定的内存开销，特别是当容器的规模很大的时候，可能有将内存撑爆的可能性存在。这时候可能要考虑别的容器。另外上边也提到了这种复制一份新的容器延迟的做法会有数据一致性的问题，如果你对写入的数据读出来实时性很高，那么久不要去选择copyOnWrite容器。 其他文章 copyOnWriteArrayList于同步集合工具容器性能比较：性能比较 简单使用：简单使用 引用说明 1.https://www.cnblogs.com/dolphin0520/p/3938914.html2.《java并发编程实战》]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发工具</category>
      </categories>
      <tags>
        <tag>copyOnWrite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——线程基础（一）]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[线程是Java学习过程中比较难理解的一part，所以要好好打下基础，之后也会对juc包等其他并发编知识去做一个具体的原理性的学习。 一些概念一、并发与并行 并发：同一个时间间隔内做很多件事情；并行：同一个时刻同时做多件事情。 其实对于这句话可以这样理解：并发是两个任务可以在重叠的时间段内启动、运行和完成。并行是任务在同一时间运行，例如，在多核处理器上，并发是独立执行过程的组合，而并行是同时执行的。并发更像是操作系统用线程模型抽象之后站在线程的角度上看到的任务的”同时“执行。 二、临界区 表示一种公有区域或者公有数据，但是每一次只有一个线程使用，其他线程想使用必须等待。进程在访问资源的时候必须经过这些步骤：【进程】–&gt;【进入区（申请资源）】–&gt;【临界区】–&gt;【退出区（释放资源）】 在进入区中资源如果被占用访问，其他进入阻塞队列等待。 阻塞：一个线程占用了临界区资源，其他需要这个资源的线程在临界区中等待，导致这些线程挂起。 非阻塞：其他线程可以同时进入临界区，但保证公有数据不被改坏。 三、锁 死锁（DeadLock）:线程之间互相等待释放资源 饥饿锁（strarvation）:某一个线程或多个线程无法获取资源，导致一直无法执行 活锁（liveLock）:可以想象为电梯遇到人，同时都往一个方向去给对方让出资源，是个动态的问题 四、并发级别 阻塞状态级别 非阻塞状态级别（这里面还分为三种）(1) 无障碍。一种最弱的非阻塞调度，自由进出临界区。无竞争时要求有限步骤内完成操作；无竞争时直接进行回滚数据。(2) 无锁。保证只有一个线程可以胜出访问临界资源。比如乐观锁（CAS）(3) 无等待的，并发中最高级别，是无锁的，要求所有的线程都在有限步内完成，并且无饥饿的。比如：读线程和写线程，所有线程都是无等待的。比如CopyOnWriteArrayList写时写副本数据，读时共享读，线程之间是无等待的。 五、并行的两个定律 加速比：优化前系统耗时/优化后系统耗时。 说明增加CPU个数不一定增加加速比。 古斯塔夫森定律：只要有足够的并行化，那么加速比和CPU个数成正比 六、线程相关知识线程和进程 进程是分配资源的基本单位，线程是CPU调度的基本单位。进程之间的资源是互相独立不可共享的，但是线程之间是可以共享父线程或者进程的资源的。进程之间切换要比线程之间切换消耗资源代价多很多。 线程的状态 新建状态（NEW）：新创建了一个线程对象 可运行状态（RUNNABLE）：线程对象创建之后，其他线程（比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。 运行（running）：可运行状态的线程获得了cpu时间片，执行程序代码。 阻塞（block）：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行（runnable）状态，才有机会再次获得cpu timeslice转到运行（running）状态。其中阻塞的状态分三种：（1）等待阻塞：运行（running）的线程执行o.wait()方法，JVM会把线程放入到等待队列（waitting queue）中。（2）同步阻塞：运行（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池（lock pool）中。（3）其他阻塞：运行（running）的线程执行Thread.Sleep(long ms)或者join方法，或者发出了IO请求，JVM会把该线程置为阻塞状态。当sleep状态超时、join()等待线程终止或者超时、或者IO处理完毕之后，线程重新转入可运行（runnable）状态。 死亡（dead）：线程run()、main()方法执行结束，或者因一场退出了run()方法，则该线程结束生命周期，死亡的线程不可再次复生。 线程状态扭转的图：可以看到：（1）当调用new Threa()方法之后，线程就会处于新建状态。（2）调用start()方法之后，线程会进入runnable状态，当操作系统选中之后给当前线程分配了时间片线程进入running状态。（3）当run()方法、main()方法结束或者发生异常，线程会进入dead状态。（4）当因为synchronize或者lock同步方法，线程没有获取到锁标识就会进入到锁池（lock pool）中等待；同样当调用o.wait()方法之后线程会进入等待队列中，这时会释放锁或者monitor，直到被其他线程的notify()方法或者notifyAll()方法唤醒。（5）当调用Thread.yield()方法之后，会使线程从running状态转换到runnable状态再去和其他线程一起去竞争时间片资源，所以会出现调用yield()方法之后又重新竞争到了资源变成running状态。（6）当调用了sleep()/join()方法之后，线程并不会释放锁或者monitor，而当sleep时间到了或者调用join()方法的线程执行完毕之后会继续进入running状态。 注意其中线程的一些方法经常在面试中问到的问题： 1.sleep方法和wait方法的区别 （1）sleep是Thread类的方法，wait是Object类的方法（2）调用sleep方法不会释放锁，wait方法会使线程释放当前的锁。（3）wait方法必须别的线程执行notify/notifyAll()方法才能重新获取CPU执行时间。 2.join()方法的本质 join方法是把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如main线程中调用t.join()时候，main线程会获得线程对象t的锁，调用对象的wait方法(等待时间)，直到该对象唤醒main线程，所以意味着main线程调用t.join()时，必须能够拿到线程t对象的锁。注意join()方法也是要捕捉异常的，关于join()方法的比较好的一篇文章：http://uule.iteye.com/blog/1101994 3.yield()方法 yield()方法与sleep()方法类似，只是不能由用户指定暂停多长时间，并且yield()方法只能让同优先级的线程有执行的机会，yield()方法不会释放对象上的锁。 4.wait()和notify()、notifyAll() 这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized中执行使用。synchronized关键字用于保护共享数据，阻止其他线程对共享数据的存取，可以用这三个方法去灵活控制。wait()方法使当前的线程暂停执行并释放对象锁标识，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中，只有锁标志等待池中线程能获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。notifyAll()方法则从对象等待池中移走所有等待那个对象的线程并放入锁标志等待池中。 wait()、notify()方法是Object类的方法，因为他们必须要标识它们操作线程的锁，而锁对象可能是任何对象，所有这里这两个方法是Object类的方法。 线程创建几种方式继承Thread类 可以继承Thread实现其中的run()方法12345678910111213141516171819202122232425262728293031323334353637public class NewThread2 extends Thread &#123; public NewThread2(String name) &#123; super(name); &#125; @Override public void run() &#123; while (!interrupted()) &#123;// 这里的循环是当不被中断的时候 才执行 System.out.println(getName() + &quot; 线程运行&quot;); &#125; &#125; public static void main(String[] args) &#123; NewThread2 t1 = new NewThread2(&quot;first thread&quot;); NewThread2 t2 = new NewThread2(&quot;second thread&quot;); t1.setDaemon(true);// 后台（守护）线程会随着主线程结束也结束 t2.setDaemon(true); t1.start(); t2.start(); // 中断不用stop()方法 已经过时 t1.interrupt(); t2.interrupt();// try &#123; // 让主线程sleep两秒 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实现Runnable接口其实看到Thread类也是实现了Runnable接口的。1234567891011121314151617181920212223242526272829303132333435363738394041424344package newthread;/** * created by zlj on 2018/5/31 * Runnable接口 创建线程 */public class NewThread implements Runnable &#123; @Override public synchronized void run() &#123; while (true) &#123; try &#123; // Thread.sleep(1000);// 调用超时等待使得线程进入阻塞状态 到达时间后线程到达就绪状态 wait();// 线程通讯必须在同步代码块中 否则会报错IllegalMonitorStateException &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;自定义线程执行...&quot;); &#125; &#125; public static void main(String[] args) &#123; NewThread newThread = new NewThread(); // 线程初始化 Thread thread = new Thread(newThread);// 构造函数是runnable接口参数 thread.start();// 调用start方法使得线程进入就绪状态 while (true) &#123; synchronized (newThread) &#123;// 这里同步代码块中监视的是同步的对象 对应上边wait方法获取的是this对象 System.out.println(&quot;主线程执行...&quot;);// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; newThread.notifyAll();// notify方法必须在同步监视器中 否则会报错 &#125; &#125; &#125;&#125; 实现Callable接口（线程可以有返回值和抛出异常）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package newthread;import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;/** * created by zlj on 2018/5/31 * 带有返回值 和 抛出异常 的线程创建 */public class NewThread4 implements Callable&lt;Integer&gt; &#123; // 实现call方法 // callable接口 和 runnable接口 比较：（1）callable接口可以传入泛型有返回值 （2）可以抛出异常 @Override public Integer call() throws Exception &#123; System.out.println(&quot;正在紧张的计算&quot;); // sleep 模拟计算过程 Thread.sleep(3000); return 1; &#125; public static void main(String[] args) &#123; NewThread4 t = new NewThread4(); /* * 对线程任务的封装 */ // 主线程可以先去做点别的 System.out.println(&quot;先去做点别的&quot;); // 首先用FutureTask&lt;T&gt; 对 call 封装成任务 FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(t); // 再根据构造函数去封装成Thread对象 传入FutureTask类型的task Thread thread = new Thread(task); thread.start(); // 拿到线程的结果 try &#123; System.out.println(&quot;计算的结果是&quot; + task.get()); // 这里注意TaskFuture的get()方法是等上边线程结束之后去进行计算结果的。也是一个闭锁操作 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程池实现1234567891011121314151617181920212223242526272829303132package newthread;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * created by zlj on 2018/5/31 * 线程池创建线程 */public class NewThread6 &#123; public static void main(String[] args) &#123; // 创建十个定长的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); // 提交一百个 线程执行的任务 for (int i=0; i&lt;100; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;); &#125; // 线程池的停止销毁 否则程序一直会运行 threadPool.shutdown(); // 注意shutdownNow方法和shutdown方法的区别 threadPool.shutdownNow(); &#125;&#125; Executors中提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。（1）public static ExecutorService newFixedThreadpPool(int nThreads) // 创建国定数目线程的线程池。（2）public static ExecutorService newCachedThreadPool() // 创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有60秒钟未被使用的线程。（3）public static ExecutorService newSingleThreadExecutor（） // 创建一个单线程化的Executor（4）public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) // 创建一个支持定时及周期性的任务执行线程池，多数情况可以用来替代Timer类。但是其实在阿里的代码检查工具中，是不建议去使用这个工具类去调用线程池的，建议去手动的写自定义的线程池。 线程中的其他常见方法 方法 说明 setPriority(int priority) 设置线程的优先级 setDaemon(boolean on) 设置是否为后台线程 interrupt() 中断线程 isAlive() 测试线程是否处于活动状态 守护线程和用户线程的区别：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法允许完毕之后，守护线程也会随着消亡，而用户线程则不依赖会一直运行到完毕为止，在JVM中像垃圾回收线程就是守护线程。但是要注意，设置守护线程要在thread.start()方法之前，否则会报IllegalThreadStateException异常。不应该所有的线程都可以分配给Deamon线程来进行服务，比如读写操作或计算逻辑，因为在Deamon Thread没来得及进行操作时，虚拟机可能已经退出了。 停止线程的方法 使用退出标志，使线程正常退出。 使用stop方法终止线程（已过时不推荐） while判断 + interrupt方法终止线程。其中interrupt方法不会终止正在运行的线程，所以要加入一个判断去完成线程的优雅退出。 一些面试题 线程和进程有什么区别？答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。 Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 线程的sleep()方法和yield()方法有什么区别？答：① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 请说出与线程同步以及线程调度相关的方法。wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 先写到这关于线程的知识总结还有很多，后边关于并发编程还要更深入的理解，这里先上一张知识总结图吧。]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式 定义一系列的算法，把每一个算法封装起来，并且使它们可以相互替换。这个模式中使得各个算法可以独立于使用它的客户而变化。 策略模式的构成：1.抽象策略角色：策略类，通常由一个接口或者抽象类实现。2.具体策略角色：包装了相关的算法和行为，实现策略接口或继承抽象类。3.环境角色：context，运行时持有一个策略类的引用，最终给客户端调用。对应的uml图片为： 策略模式让算法独立于使用它的客户而独立变化。策略模式重点是封装不同的算法和行为，不同的场景下可以相互替换。策略模式是开闭原则的体现，开闭原则讲的是一个软件实体应该对拓展开放对修改关闭。因为策略模式在加入新的策略时，不会影响其他类的修改，增加了拓展性，也就是对拓展是开放的；对于调用场景来说，只依赖于抽象，而不依赖于具体实现，所以对修改是关闭的。 策略模式的优点和缺点优点：（1）调用策略中的方法在context中，没有和各个策略的实现耦合在一起，各个实现策略的不同子类可以去拓展、修改和切换。（2）避免写很多if else代码，提高了可观性。同时可以结合抽象类（策略类）去使用，Java支持很好。缺点：（1）客户端调用时必须知道所有的策略类，并且感知到要调用哪一种策略实现。（2）一旦抽象，必然会对一些特殊场景难以处理。并且这里去加入了很多的策略实现类，也有Context类的加入，增加了开销。 代码示例比如现在支付方式有四种，这其中每一种方式都对应着不同的最后费用。这样可以应用策略模式。 Strategy.java12345678910111213package design_pattern.strategy_pattern.intf;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;/** * 抽象策略角色Strategy接口 * @author 夸克 * @create 2018/7/23 17:56 */public interface Strategy &#123; // 定义计算recharge的方法 Double calRecharge(Double charge);&#125; 2.StrategyContext.java123456789101112131415161718192021222324package design_pattern.strategy_pattern.context;import design_pattern.strategy_pattern.factory.StrategyFactory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * 策略模式中的环境角色 context * @author 夸克 * @create 2018/7/24 14:57 */public class Context &#123; private Strategy strategy; public Double calRecharge(Double charge, Integer type) &#123; // 利用一个工厂去生成对应的策略 strategy = StrategyFactory.getInstance().creator(ReChargeTypeEnum.from(type)); if (strategy == null) &#123; throw new RuntimeException(&quot;策略生成错误&quot;); &#125; return strategy.calRecharge(charge); &#125;&#125; 3.策略工厂，返回对应的策略12345678910111213141516171819202122232425262728293031323334353637383940package design_pattern.strategy_pattern.factory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;import design_pattern.strategy_pattern.strategy.BusiAcctStrategy;import design_pattern.strategy_pattern.strategy.CardStrategy;import design_pattern.strategy_pattern.strategy.EBankStrategy;import design_pattern.strategy_pattern.strategy.MobileStrategy;import java.util.HashMap;import java.util.Map;/** * 策略工厂 负责Strategy实例的创建 根据传入的type实现创建不同的策略 * @author 夸克 * @create 2018/7/24 15:01 */public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private static Map&lt;ReChargeTypeEnum, Strategy&gt; map = new HashMap&lt;&gt;(); static &#123; map.put(ReChargeTypeEnum.E_BANK, new EBankStrategy()); map.put(ReChargeTypeEnum.BUSI_ACCOUNTS, new BusiAcctStrategy()); map.put(ReChargeTypeEnum.MOBILE, new MobileStrategy()); map.put(ReChargeTypeEnum.CARD_RECHARGE, new CardStrategy()); &#125; /** * getInstance方法进行初始化 * @return */ public static StrategyFactory getInstance() &#123; return factory; &#125; public Strategy creator(ReChargeTypeEnum type) &#123; return map.get(type); &#125;&#125; 四种策略的实现：12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:53 */public class BusiAcctStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.9; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:57 */public class CardStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge + charge * 0.01; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:52 */public class EBankStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.85; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:54 */public class MobileStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge; &#125;&#125; Main.java12345678910111213141516171819202122232425package design_pattern.strategy_pattern.main;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.context.Context;/** * @author 夸克 * @create 2018/7/26 23:30 */public class StrategyMain &#123; public static void main(String[] args) &#123; Context context = new Context(); /** * 计算四种计算方式 */ Double aDouble = context.calRecharge(100D, ReChargeTypeEnum.E_BANK.getValue()); Double bDouble = context.calRecharge(100D, ReChargeTypeEnum.BUSI_ACCOUNTS.getValue()); Double cDouble = context.calRecharge(100D, ReChargeTypeEnum.MOBILE.getValue()); Double dDouble = context.calRecharge(100D, ReChargeTypeEnum.CARD_RECHARGE.getValue()); System.out.println(aDouble + &quot;\t&quot; + bDouble + &quot;\t&quot; + cDouble + &quot;\t&quot; + dDouble); &#125;&#125; github代码已经上传至我的github：https://github.com/zhanglijun1217/java8/tree/master/src/design_pattern/strategy_pattern 引用https://www.jianshu.com/p/71feb016ac05]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[orika转换bean的字段丢失]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2Forika%E8%BD%AC%E6%8D%A2bean%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%A2%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[背景 用orika对象转换工具去转换list的时候，发现只去完整转了list的第一条数据，但是后边的数据都没有将字段全部映射上去。 描述： 1.debug时发现的，源数据list是数据都存在的 2.转完之后的list数据，发现userName、realName等字段是丢失的。 解决经过排查发现是因为在转换注册的字段中，有个type字段没有对应的注册上去。这里就造成了orika这个转换工具丢失了list中记录字段的数据转换。 这里去记录一下这次碰到的小bug，其实也是粗心导致的。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>orika</tag>
        <tag>bug</tag>
      </tags>
  </entry>
</search>
