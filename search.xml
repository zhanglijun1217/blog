<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次freemarker错误排查]]></title>
    <url>%2Fblog%2F2018%2F08%2F29%2F%E8%AE%B0%E4%B8%80%E6%AC%A1freemarker%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[前言在最近的工作中遇到了一个做一个导出功能时遇到了一个很奇怪的事情，逻辑是先做一个export方法上传到文件服务器上，然后重定向到一个doExport方法中，这个doExport方法中是去判断这个文件是否生成（之前生成Excel文件是异步线程生成的），如果没有生成，则转到一个export.ftl的freemarker页面，这个页面中去不断reload去调用这个doExport方法，直到导出了文件。但是在本地测试的时候，总发现doExport方法会无限的将请求再转发到export方法中，然后就一直产生了无限重定向，在浏览器中会有报无限重定向而给拦截掉。 现象两个controller： 模板文件： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;报表导出&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot; border:1px solid #ccc; margin:200px auto; height:70px;background:#eee;padding:40px;color:green;text-align:center;&quot;&gt;正在生成报表，请耐心等待...&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; setTimeout(&quot;location.reload()&quot;, 1000);&lt;/script&gt;、&lt;/body&gt;&lt;/html&gt; 本地开启debug模式进行调试： 可以看到现在是线程nio-7001-exec-1去发送到重定向到下边的doExport方法 此时在doExport中是新的exec-2线程去调用这个方法判断文件是否存在 同样的是这个线程去返回modelAndView，按理说这时候应该返回模板类freemarker中的export.ftl，但是它没有去返回freemarker文件，而是将这个请求转发到了export方法： 而且是同一个线程，是容器内跳转。之后因为每次export方法都会去生成一个新的随机的文件名称，所以又会去调用doExport方法去下载新的文件名称的文件，直到有一个个文件内容比较少，异步线程在判断文件是否存在之前，文件导出，否则浏览器会直接拦截这么多次的重定向： 排查过程是不是freemarker的文件路径配置有问题既然是容器内跳转，而没有访问到真正的导出页面的文件，那是不是freemarker的文件访问路径配置有问题。看到本地环境的properties文件中关于freemarker配置如下： 12345678# freemarker相关配置spring.freemarker.enabled=truespring.freemarker.suffix=.ftlspring.freemarker.content-type=text/htmlspring.freemarker.cache=falsespring.freemarker.charset=utf-8spring.freemarker.check-template-location=truespring.freemarker.template-loader-path=classpath:/templates/ 这里去查看了模板文件确实是放在了classpath下的templates文件夹中的。所以配置和访问文件的路径没有问题。 是不是因为mapping重名，优先映射到了mapping地址这里发现模板文件的名称和export的mapping地址是一样的，则在exprot方法上加了一个1,saleDetail/exprot1这样，然后再次debug发现，这时候不会再重新容器内跳转到这个方法，但是页面直接报了404错误，这说明还是没有去加载到模板文件。 进行一个简答的路由到模板文件的测试这时候去写了一个helloController，然后在templetes下新建了一个hello.ftl模板文件，在controller中去return modelAndView，这时视图也是hello，发现也是404的错误。这说明和sendRedirect方法也没有关系，本身项目是不支持freemarker的。 最后发现在整个项目中，都没有freemarker的依赖和jar包。。。加入freemarker的依赖之后问题解决。 因为mapping地址和freemarker的模板文件地址相同，在你返回modelAndView的视图名称在mapping中找的到时，springmvc会容器内跳转，也不会报freemarker模板文件找不到的错误。因为其他工程也是这样去写的，所以就想当然的以为这个工程中也会有freemarker依赖。其实这个时候应该跟一下spring mvc的源码，就可以看到这时候跳转的是dispatcherServlet路由到的export方法，并没有走freemarker的模板文件。这里去记录一下。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot actuator]]></title>
    <url>%2Fblog%2F2018%2F08%2F25%2Fspring-boot-actutor%2F</url>
    <content type="text"><![CDATA[前言spring boot的一大特性就是自带的actuator。它是spring-boot框架提供的对应系统的自省和监控的集成功能，可以对系统进行配置查看、相关功能统计等。 actuator的使用引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件的配置 management.port:指定访问监控防范的端口，这个端口应该与逻辑端口分离。如果不想使actuator暴露在http中，可以设置这个端口为-1。 management.address：指定地址，比如只能通过本机监控，可以设置 management.address = 127.0.0.1启动项目，可以看到actuator启动在了配置的7002端口，并且提供了可以访问其中的一些endPoints。 一些主要的EndPointsspring-boot提供了一些常用的EndPoints其中鉴权为true的表示访问这些endPoints是需要保护的不能随意进行访问的。如果要取消，可以设置关闭鉴权（低版本的spring-boot没有提供鉴权）1management.security.enable=false 官方文档可以看到这个监控和自省的功能是十分有用的，可以看到bean信息、dump信息、mapping信息和访问链路信息等，所以这个功能在官方文档中也说的很清楚，我们也可以通过实现HealthIndicator接口，编写自己的health接口，也可以增加自己的监控接口。具体的还可以看一下官方文档 acautor文档]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>actuator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[validate注解做校验]]></title>
    <url>%2Fblog%2F2018%2F08%2F18%2Fvalidate%E6%B3%A8%E8%A7%A3%E5%81%9A%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[前言之前也用过hibernate的校验注解，但是没有去做一个总结，这里参考一篇博客去做一个总结。简述JSR303/JSR-349，hibernate validation，spring validation之间的关系。JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。而hibernate validation是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。而万能的spring为了给开发者提供便捷，对hibernate validation进行了二次封装，显示校验validated bean时，你可以使用spring validation或者hibernate validation，而spring validation另一个特性，便是其在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中。这无疑便捷了我们的web开发。本文主要介绍在springmvc中自动校验的机制。 引入依赖因为我们构建的是spring boot项目，所以直接引入web的starter的依赖即可。123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果查看其子依赖，可以发现如下的依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; 进行校验校验的实体类这里用了lombok的@Data注解，也是非常推荐大家使用的一个插件。12345678910111213141516171819202122232425@Datapublic class ValidateBO &#123; @NotBlank(message = &quot;name不能为空&quot;) private String name; @Min(value = 18, message = &quot;年龄不能小于18岁&quot;) private Integer age; @Email(message = &quot;email格式错误&quot;) private String email; /** * 自定义注解 不能包含空格字符串 */ @CannotHaveBlank private String blank; /** * 正则校验 */ @Pattern(regexp = &quot;^1(3|4|5|7|8)\\d&#123;9&#125;$&quot;, message = &quot;手机号码格式错误&quot;) private String phone;&#125; 可以看到这里用到了一些常见的注解。（自定义校验注解在下边会提到） controller进行校验在controller中进行这个字段的校验，可以看到每个需要校验的对象，都需要一个BindingResult去承接校验的结果，并且也要对要校验的类去加上@Validated注解。123456789101112@GetMapping(value = &quot;/validate&quot;) public String validate(ValidateBO validateBO, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; StringBuilder stringBuilder = new StringBuilder(); for (String s : bindingResult.getFieldErrors().stream() .map(FieldError::getDefaultMessage).collect(Collectors.toList())) &#123; stringBuilder.append(s); &#125; return stringBuilder.toString(); &#125; return &quot;success&quot;; &#125; 启动项目，在url中输入对项目进行debug。可以看到，校验在碰到第一个字段不符合要求之后，并不是直接返回错误，而是会对所有的要校验字段去校验。当然这个也是可以配置的，下边会提到fast-fail的配置。最后返回的结果：这里是打印出了这个对象中所有的错误。 常见的校验注解JSR提供的校验注解:12345678910111213@Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator提供的校验注解：12345@NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 分组校验场景如果同一个类，在不同的使用场景下有不同的校验规则，那么可以使用分组校验。未成年人是不能喝酒的，而在其他场景下我们不做特殊的限制，这个需求如何体现同一个实体，不同的校验规则呢？ 校验对象12345678910111213@Datapublic class ValidateByGroupBO &#123; /** * 只有adult组内才进行 validate 校验 */ @Min(value = 18, groups = &#123;Adult.class&#125;) private Integer age; public interface Adult&#123;&#125; public interface Minor&#123;&#125;&#125; 这就定义了只有在在adult组内才会进行最小值18的校验。 进行验证1234567891011121314151617181920212223242526272829/** * 喝酒这个去校验了年龄值，因为只有adult这个组才去校验年龄 * @param validateByGroupBO * @param bindingResult * @return */ @GetMapping(value = &quot;/drink&quot;) public String drink(@Validated(&#123;ValidateByGroupBO.Adult.class&#125;) ValidateByGroupBO validateByGroupBO, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; // 处理错误 return &quot;false&quot;; &#125; return &quot;success&quot;; &#125; /** * 生活不需要去校验adult的分组 就不去校验对应的age的最小值 * @param validateByGroupBO * @param bindingResult * @return */ @GetMapping(value = &quot;live&quot;) public String live(@Validated ValidateByGroupBO validateByGroupBO, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; // 错误处理 return &quot;false&quot;; &#125; return &quot;success&quot;; &#125; 运行之后，在url中输入http://localhost:7001/drink?age=10，第一个返回false，因为指定了使用其中的Adult分组，会开启对age的校验。输入http://localhost:7001/live?age=10则会不去校验age的大小，返回success。喝酒要校验是否成年，而生活不用，类似的场景还是很容易碰到的。 自定义注解实现一个注解这里去实现一个字符串中不能含有blank空格。主要分为两步： 先去定义这个注解，其中validatedBy指定的是真正去做校验的实体类。而其中的groups和payload可以直接用默认。 123456789101112131415161718192021222324@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, ElementType.CONSTRUCTOR, PARAMETER&#125;)@Retention(RUNTIME)@Documented// 这个注解是引入真正的去做验证的类@Constraint(validatedBy = &#123;CannotHaveBlankValidator.class&#125;)public @interface CannotHaveBlank &#123; // 默认错误信息 String message() default &quot;不能包含空格&quot;; // 分组 Class&lt;?&gt;[] groups() default &#123;&#125;; //负载 Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; //指定多个时使用 @Target(&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;) @Retention(RUNTIME) @Documented @interface List &#123; CannotHaveBlank[] value(); &#125;&#125; 第二步是去实现真正去做校验的实体类 12345678910111213141516171819202122232425public class CannotHaveBlankValidator implements ConstraintValidator&lt;CannotHaveBlank, String&gt; &#123; @Override public void initialize(CannotHaveBlank cannotHaveBlank) &#123; &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //null时不进行校验 if (value != null &amp;&amp; value.contains(&quot; &quot;)) &#123; //获取默认提示信息 String defaultConstraintMessageTemplate = context.getDefaultConstraintMessageTemplate(); System.out.println(&quot;default message :&quot; + defaultConstraintMessageTemplate); //禁用默认提示信息 context.disableDefaultConstraintViolation(); //设置提示语 context.buildConstraintViolationWithTemplate(&quot;can not contains blank&quot;) .addConstraintViolation(); return false; &#125; return true; &#125;&#125; 这里去实现类去实现了ConstraintValidator接口，这个接口中包含一个初始化事件方法和一个判断是否合法的方法：123456789package javax.validation;import java.lang.annotation.Annotation;public interface ConstraintValidator&lt;A extends Annotation, T&gt; &#123; void initialize(A var1); boolean isValid(T var1, ConstraintValidatorContext var2);&#125; 其中的A泛型参数是上一步定义的注解类，泛型T是要去校验的字段类型。ConstraintValidatorContext 这个参数上下文包含了认证中所有的信息，我们可以利用这个上下文实现获取默认错误提示信息，禁用错误提示信息，改写错误提示信息等操作。 自定义注解进行校验还是用第一个controller去验证这个自定义注解。因为要校验的对象中加入了自定义注解的blank字段。启动项目，输入http://localhost:7001/validate?blank=19 209（这里加了空格），可以看到返回值是：说明自定义注解起到了作用。 @Valid 和 @Validated的区别https://blog.csdn.net/qq_27680317/article/details/79970590这篇讲的很清晰了。 aop很显然，如果我们每个controller中的方法都去写BindingResult就显得很麻烦了，其实我们就是要对参数进行校验并且输出到log中，这就很自然的想到了aop。 注解标识定义一个注解去标识使用了hibernate validate注解123456789101112131415161718192021package com.zhanglijun.springbootdemo.domain.anno;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.validation.groups.Default;/** * 用来表示开启hibernate校验的注解 * @author 夸克 * @create 2018/8/19 22:28 */@Target(&#123;ElementType.METHOD,ElementType.TYPE,ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface EnableValidate &#123; Class&lt;?&gt; [] groups() default &#123; Default.class &#125;;//校验分组信息&#125; 定义切面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162package com.zhanglijun.springbootdemo.aspect;import com.zhanglijun.springbootdemo.domain.anno.EnableValidate;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import java.util.HashSet;import java.util.Set;import javax.validation.ConstraintViolation;import javax.validation.ConstraintViolationException;import javax.validation.Validation;import javax.validation.Validator;import javax.validation.executable.ExecutableValidator;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.hibernate.validator.HibernateValidator;import org.springframework.core.annotation.AnnotationUtils;import org.springframework.stereotype.Component;import org.springframework.util.ClassUtils;/** * @author 夸克 * @create 2018/8/19 18:45 */@Slf4j@Aspect@Componentpublic class ValidatorAspect &#123; /** * 获取校验的工厂的信息 */ private static final Validator validator = Validation.byProvider(HibernateValidator.class) .configure() //快速失败模式开启，当检测到有一项失败立即停止 .failFast(true) .buildValidatorFactory().getValidator(); /** * point配置 */ @Pointcut(&quot;execution(* com.zhanglijun.springbootdemo.web.controller..*.*(..))&quot;) public void pointcut() &#123; &#125; /** * @desction: 校验步骤 1.首先校验是否含有基本的Hibernate validator 注解，有异常抛出 2.校验方法参数中是否含有EgValidate注解，获取分组信息，进行Bean级别的校验，有异常抛出 * 3.查看当前的方法中（优先级高）(或者父类、父接口)是否含有EgValidate注解，没有获取当前类的中是否是否含有EgValidate注解，获取分组信息，针对每一个非基本类型Bean进行校验，有异常掏出 * @author: wangji * @date: 2018/3/13 10:16 */ @Before(&quot;pointcut()&quot;) public void before(JoinPoint point) &#123; // 获得切入目标对象 Object target = point.getThis(); // 获得切入方法参数 Object[] args = point.getArgs(); // 获得切入的方法 Method method = ((MethodSignature) point.getSignature()).getMethod(); Annotation[] classAnnotations = target.getClass().getAnnotations(); Annotation[] methodAnnotations = method.getAnnotations(); Annotation[][] parameterAnnotations = method.getParameterAnnotations(); //如果方法参数有基本的注解，就进行Hibernate validator 基本的参数校验 if (parameterAnnotations != null) &#123; validMethodParams(target, method, args); &#125; // 判断参数中是否含有EgValidate注解，进行特殊分组，Bean级别的参数校验 int i = 0; //排查掉已经在参数中校验过的参数不适用类或者方法上的校验参数在次进行校验 Set&lt;Integer&gt; idSet = new HashSet&lt;&gt;(3); for (Object arg : args) &#123; if (arg != null) &#123; if (parameterAnnotations != null) &#123; for (Annotation parameterAnnotation : parameterAnnotations[i]) &#123; if (parameterAnnotation instanceof EnableValidate) &#123; if (!ClassUtils.isPrimitiveOrWrapper(arg.getClass())) &#123; validBeanParam(arg, ((EnableValidate) parameterAnnotation).groups()); idSet.add(i); &#125; &#125; &#125; &#125; i++; &#125; &#125; // 如果没有异常继续校验当前的每一个非基本类型的参数 EnableValidate egValidate = null; //方法上是否有校验参数 if (methodAnnotations != null) &#123; egValidate = AnnotationUtils.findAnnotation(method, EnableValidate.class); &#125; // 类上是否含有 if (egValidate == null &amp;&amp; classAnnotations != null) &#123; egValidate = AnnotationUtils.findAnnotation(target.getClass(), EnableValidate.class); &#125; // 如果在类或者方法上加了验证注解 ，则对所有非基本类型的参数对象进行验证,不管参数对象有没有加注解，使用方法上的分组 if (egValidate != null &amp;&amp; args != null &amp;&amp; args.length &gt; 0) &#123; i = 0; for (Object arg : args) &#123; if (arg != null &amp;&amp; !ClassUtils.isPrimitiveOrWrapper(arg.getClass()) &amp;&amp; !idSet .contains(i)) &#123; validBeanParam(arg, egValidate.groups()); &#125; i++; &#125; &#125; &#125; /** * @param obj 参数中的Bean类型参数 * @param groups 分组信息 * @desction: 进行参数中的Bean校验 * @author: wangji * @date: 2018/3/13 10:10 */ private void validBeanParam(Object obj, Class&lt;?&gt;... groups) &#123; Set&lt;ConstraintViolation&lt;Object&gt;&gt; validResult = validator.validate(obj, groups); throwConstraintViolationException(validResult); &#125; /** * @param obj 当前的实例 * @param method 实例的方法 * @param params 参数 * @desction: 对于Hibernate 基本校验Bean放在参数中的情况的校验 【例如 User getUserInfoById(@NotNull(message = * &quot;不能为空&quot;) Integer id);】 * @author: wangji * @date: 2018/3/13 10:11 */ private void validMethodParams(Object obj, Method method, Object[] params) &#123; ExecutableValidator validatorParam = validator.forExecutables(); Set&lt;ConstraintViolation&lt;Object&gt;&gt; validResult = validatorParam .validateParameters(obj, method, params); throwConstraintViolationException(validResult); &#125; /** * @desction: 判断校验的结果是否存在异常 * @author: wangji * @date: 2018/3/13 10:09 */ private void throwConstraintViolationException(Set&lt;ConstraintViolation&lt;Object&gt;&gt; validResult) &#123; if (!validResult.isEmpty()) &#123; throw new ConstraintViolationException(validResult.iterator().next().getMessage(), validResult); &#125; &#125;&#125; 这个切面说的也很清除，对多处使用这个的地方都去做了一个校验。 github上述代码都在我的github，可以在review一下代码。validated注解相关 引用参考的博客： https://www.cnkirito.moe/spring-validation/ https://blog.csdn.net/oKuZuoZhou/article/details/81024795 https://blog.csdn.net/u012881904/article/details/79538895]]></content>
      <categories>
        <category>spring</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>validate注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——ThreadLocal总结]]></title>
    <url>%2Fblog%2F2018%2F08%2F16%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94ThreadLocal%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概念介绍ThreadLocal是早期jdk版本中就有的一个工具，基本原理是同一个ThreadLocal所包含的对象（对ThreadLocal而言即为String类型变量），在不同的Thread中有不同的副本（实际是不同的实例）。这里有几点需要注意： 因为每个Thread内有自己的实例副本，且该副本只能由当前的Thread使用。这也是ThreadLocal命名的由来。 既然每个Thread都有自己的实例副本，且其他的Thread不可访问，那么就不存在多线程共享的问题（其实ThreadLocal也不是去解决多线程共享的问题）。 那么ThreadLocal解决了什么问题呢？ThreadLocal提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal变量通常被private static修饰。当一个线程结束时，它所使用的ThreadLocal相对的实例副本都可被回收。 ThreadLocal的适用场景：ThreadLocal适用于每个线程需要自己独立的实例且该实例需要在多个方法中使用，也即变量在线程间隔离而在方法或类间共享的场景。其实这种场景下并不只是可以用ThreadLocal去解决，只不过ThreadLocal更简洁。 ThreadLocal原理实现可能的猜想ThreadLocal维护线程与实例的映射 既然每个访问ThreadLocal变量的线程都有自己的一个“本地”实例副本，那么可能的方案是ThreadLocal维护着一个Map，键是Thread，值是它在这个Thread中的实例。线程通过该ThreadLocal的get()方法获取实例时，只需要以线程为键，从map中获取实例即可。 这个方案却又有问题： 增加线程和减少线程都需要去put、remove操作map,这个时候如果在一个ThreadLocal对该线程存入两个实例，就会有线程安全问题、 线程结束时，需要保证它所访问的所有的ThreadLocal中的对应的映射均删除，否则可能会引起内存泄漏。 第一个问题是jdk不去采取这种做法的原因。 ThreadLocal维护ThreadLocal与实例的映射 如果这个Map是每个线程去访问自己的一个Map，就不会产生多线程写的问题。map中维护着key为ThreadLocal实例，设计如下图所示。 这个方案中解决了map的线程安全问题，相当于第一种方法的倒转想法，map中key设置为ThreadLocal实例在不同线程中访问。 这种方案还是没有去解决内存泄漏问题。由于每个线程访问到ThreadLocal变量之后，都会在自己的Map内维护该ThreadLocal变量与具体实例的映射，如果不删除这些引用（映射），则这些ThreadLocal不能被回收，可能会造成内存泄漏。 JDK中的解决ThreadLocalMap 上边提到的维护的map是由ThreadLocal中的静态内部类ThreadLcoalMap去提供的，该类的实例维护着某个ThreadLocal与具体实例的映射。与HashMap不同的是，每个ThreadLocalMap的每一个Entry都是一个对键的弱引用，这一点可以从super(k)可以看出。每一个Entry对key的引用是强引用。使用ThreadLocal弱引用的原因是可以被及时回收。但是这里不能解决Entry引用内存泄漏的问题。当ThreadLocal变量被回收之后，该映射的键值变为null，该Entry无法被移除。从而也有可能造成内存泄漏。（下面会提到JDK的解决）ThreadLocalMap中的Entry代码如下：12345678static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 读取实例12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 读取实例时，线程首先通过getMap(t)方法获取自身的ThreadLocalMap。获取到ThreadLocalMap后，通过map.getEntity(this)方法获取该ThreadLocal在当前线程的ThreadLocalMap中的Entry。该方法中的this即当前访问的ThreadLocal方法。如果获取到的Entry不为null，从Entry中取出值即为所需访问的本线程对应的实例。如果获取到的Entry为null，则通过setInitialValue()方法设置该ThreadLocal变量在该线程中对应的具体实例的初始值。设置初始值的方法如下： 12345678910private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 注意此方法为private方法，无法被重载。 首先，通过initialValue()方法能生成一个初始值，这个方法是一个public方法，且默认值为null。所以典型用法中常常去重载该方法去给一个默认值。然后，通过当前线程对象拿到ThreadLocalMap对象，若该对象不为null，则直接塞入map中set进去线程内实例的值。如果map为null，则去创建该ThreadLcoalMap对象。 设置实例。 设置实例的方法也是采用了上述方法中的原理，不多做解释了。12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 防止内存泄漏 对于已经不再使用且已被回收的ThreadLocal对象，它在每个线程内对应的实例由于被线程的TheradLcoalMap的Entry强引用，无法被回收，可能会造成内存泄漏。 针对该问题，ThreadLocal的set方法中去做了处理。replaceStaleEntry方法将所有键为null 的Entry的值设置为null，从而使得该值可被回收。另外，会在rehash方法中通过 expungeStaleEntry 方法将键和值为null的Entry设置为null从而使得该 Entry可被回收。通过这种方式，ThreadLocal可防止内存泄漏。 1234567891011121314151617181920private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; ThreadLocal的适用场景 每个线程需要自己有单独的实例 实例需要在对个方法中共享，但不希望被多线程共享。 Threadlocal一个工具类总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * threadLocal工具类 * @author 夸克 * @create 2018/8/15 16:47 */public class ThreadLocalUtil &#123; /** * 不同的业务区分ThreadLocal中map的key * （这里的map不是threadLocal中对应线程的threadLocalMap，而是要塞入线程中的map的值， * 这里可能在一个业务域中一个线程存在多次使用ThreadLocal，所以在threadLocal中塞入的是个map。而 * 当前线程中存放的是&lt;threadLocal对象,&lt;业务key, 真正要使用的变量&gt;&gt;） * threadLocal内存泄漏问题（（1）ThreadLocalMap中Entry的引用没有释放）在jdk8中得到了解决， * 对ThreadLocalMap中的键值threadLocal实例的引用改为弱引用 * 所以建议使用ThreadLocal */ /** * 业务前缀key值的维护 */ public enum Key &#123; /** * 测试使用 */ COMMON_TEST(&quot;COMMON_TEST&quot;); private String key; Key(String key) &#123; this.key = key; &#125; &#125; private static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;(); /** * set方法 * @param key * @param value */ public static void set(String key, Object value) &#123; if(THREAD_LOCAL.get() == null) &#123; // 初始化 init(); &#125; if (StringUtils.isEmpty(key) || Objects.isNull(value)) &#123; return; &#125; THREAD_LOCAL.get().put(key, value); &#125; /** * get方法 * @param key * @return */ public static Object get(String key) &#123; if (StringUtils.isEmpty(key)) &#123; return null; &#125; return THREAD_LOCAL.get().get(key); &#125; /** * 刷新方法 */ public static void refresh() &#123; if (THREAD_LOCAL.get() == null) &#123; return; &#125; // map清除 key value THREAD_LOCAL.get().clear(); // 清除map THREAD_LOCAL.set(null); // 线程中ThreadLocalMap remove THREAD_LOCAL.remove(); &#125; private static void init() &#123; THREAD_LOCAL.set(Maps.newHashMap()); &#125;]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>ThreadLcoal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring中根据Application获取BEAN的工具类]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2Fspring%E4%B8%AD%E6%A0%B9%E6%8D%AEApplication%E8%8E%B7%E5%8F%96BEAN%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[背景 在最近的开发工作中，用到了策略模式（之前也写过关于策略模式这个设计模式的学习，但是之前那个不是在spring框架中），这时候策略中的context或者factory就要去动态的根据调用的策略类型不同去拿到对应的bean对象，这里去了解了一个通过application context拿取bean的工具类，这里记录一下。 话不多说，直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Component@Slf4jpublic class ApplicationContextBeanUtil implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; /** * 利用aware注入application * @param applicationContext * @throws BeansException */ @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; // 注入application ApplicationContextBeanUtil.applicationContext = applicationContext; &#125; private static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; /** * 通过name获取bean * @param name * @return */ public static Object getBean(String name) &#123; return getApplicationContext().getBean(name); &#125; /** * 通过class获取bean * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(clazz); &#125; /** * 通过name和class获取bean * @param name * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(name, clazz); &#125; /** * 根据clazz类型获取spring容器中的对象 * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBeansOfType(clazz); &#125; /** * 根据注解类从容器中获取对象 * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; Map&lt;String, Object&gt; getBeansOfAnnotation(Class&lt;? extends Annotation&gt; clazz) &#123; return getApplicationContext().getBeansWithAnnotation(clazz); &#125;&#125; 这是通过实现ApplicationContextAware接口去实现注入application的，这里应该注意几点： application应该是静态的。这个Util类应该是在别的类中直接调用获取bean的静态方法，所以注入的applicationContext应该都是该类的静态变量。 要用注解或者在xml文件中将这个Util配置成bean。（这里用的spring boot，就直接配置的扫描）。 在其中提供了一些获取bean的方法。 这里去记录下，方便在之后的工作中遇到了之后去直接使用]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8中list转map方法总结]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2FJava8%E4%B8%ADlist%E8%BD%ACmap%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景 在最近的工作开发之中，慢慢习惯了很多Java8中的Stream的用法，很方便而且也可以并行的去执行这个流，这边去写一下昨天遇到的一个list转map的场景。 list转map在Java8中stream的应用常用方式1.利用Collectors.toMap方法进行转换123public Map&lt;Long, String&gt; getIdNameMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getId, Account::getUsername));&#125; 其中第一个参数就是可以，第二个参数就是value的值。 2.收集对象实体本身 在开发过程中我们也需要有时候对自己的list中的实体按照其中的一个字段进行分组（比如 id -&gt;List），这时候要设置map的value值是实体本身。123public Map&lt;Long, Account&gt; getIdAccountMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getId, account -&gt; account));&#125; account -&gt; account是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法 Function.identity()，这个方法返回自身对象，更加简洁 重复key的情况。 在list转为map时，作为key的值有可能重复，这时候流的处理会抛出个异常：Java.lang.IllegalStateException:Duplicate key。这时候就要在toMap方法中指定当key冲突时key的选择。(这里是选择第二个key覆盖第一个key)123public Map&lt;String, Account&gt; getNameAccountMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getUsername, Function.identity(), (key1, key2) -&gt; key2));&#125; 用groupingBy 或者 partitioningBy进行分组 根据一个字段或者属性分组也可以直接用groupingBy方法，很方便。 12345678Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());&#125; partitioningBy可以理解为特殊的groupingBy，key值为true和false，当然此时方法中的参数为一个判断语句（用于判断的函数式接口） 12345Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println(&quot;Children number: &quot; + children.get(true).size());System.out.println(&quot;Adult number: &quot; + children.get(false).size()); 关于stream使用的好文推荐： 这里去看了ibm的一篇关于stream的文章，get到了不少stream还没遇到过的用法。老铁们可以去学习一下。[https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/ ]]]></content>
      <categories>
        <category>Java语法</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——CopyOnWrite容器]]></title>
    <url>%2Fblog%2F2018%2F08%2F04%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94CopyOnWrite%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。 什么是CopyOnWrite容器从字面意思上看是写时复制的容器。通俗理解就是我们往一个容器中添加元素时，不直接往容器中添加，而是先将容器copy，复制出一个新的容器，然后新的容器里添加元素，添加完新的元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，但不需要加锁，因为当前在读的容器中不会添加新的元素，运用一种读写分离容器的思想。 copyOnWriteArrayList实现原理来看几个方法（1）add (E e)这里是要加锁的，因为在add的时候是要Arrays.copyOf出一个容器副本的，如果多线程访问会造成copy多个容器副本出来。可以看到是在copy完成添加元素之后去将引用指向这个新的数组。1234567891011121314151617181920/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; （2）get(int index)读的时候并没有加锁，如果读的时候有线程同时去添加元素，还是会读到之前的旧的容器，所以并不用加速，但要求对读的数据一致性没那么高。123456789/** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; return get(getArray(), index);&#125; 应用场景 copyOnWrite并发容器用于读多写少的并发场景。比如白名单、黑名单、商品类目等。比如有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单每晚会更新一次。当用户搜索时，会检查关键字在不在黑名单中，如果在，则提示不能搜索。 另外迭代操作远远大于修改操作时，才应该使用“写入时复制”容器。这个准则很好的描述了许多事件通知系统：在分发通知时需要迭代已注册监听器链表，并调用每个监听器，在大多数情况下，注册和注销事件监听器的操作远少于接受事件通知的操作。 copyOnWriteArrayList用于替代同步list，在某些情况下它提供了更好的并发性能，并且能在迭代期间不需要对容器进行加锁或者复制。 实现一个copyOnWriteMap容器 简单根据“写入时复制”的思想实现一个map容器，并做简单测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package collection;import java.util.AbstractMap;import java.util.HashMap;import java.util.Map;import java.util.Set;/** * 简单根据CopyOnWrite容器的思想去实现一个map 只实现了get put putAll方法 且一些临界异常条件没有去处理 * * @author 夸克 * @create 2018/7/8 15:58 */public class CopyOnWriteMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable &#123; private volatile Map&lt;K, V&gt; internalMap; public CopyOnWriteMap() &#123; internalMap = new HashMap&lt;&gt;(); &#125; /** * 此方法未实现 */ @Override public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123; return null; &#125; @Override public V get(Object key) &#123; // 读时不加锁 return internalMap.get(key); &#125; @Override public V put(K key, V value) &#123; // 写时复制加锁 synchronized (this) &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap); V val = newMap.put(key, value); internalMap = newMap; return val; &#125; &#125; @Override public void putAll(Map&lt;? extends K, ? extends V&gt; data) &#123; synchronized (this) &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;&gt;(internalMap); newMap.putAll(data); internalMap = newMap; &#125; &#125; public static void main(String[] args) &#123; CopyOnWriteMap&lt;Integer, Integer&gt; copyOnWriteMap = new CopyOnWriteMap(); // 初始化数据 Map&lt;Integer, Integer&gt; map = new HashMap(); for (int i = 0; i &lt; 10; i++) &#123; map.put(i, i); &#125; // 读五次线程 for (int i = 0; i &lt; 5; i++) &#123; Thread read = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 方便写线程写入数据 如果不加sleep 是读不到数据的，因为是在新复制的容器中写。 // 测试copyOnWrite思想 Thread.sleep(500); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(copyOnWriteMap.get(5)); &#125; &#125;); read.start(); &#125; // 写线程 Thread write = new Thread(new Runnable() &#123; @Override public void run() &#123; map.forEach((k, v) -&gt; &#123; copyOnWriteMap.put(k, v); &#125;); &#125; &#125;); write.start(); &#125;&#125; 代码地址https://github.com/zhanglijun1217/juc 缺点 显然，每次修改容器的时候都会复制底层数组，这回造成一定的内存开销，特别是当容器的规模很大的时候，可能有将内存撑爆的可能性存在。这时候可能要考虑别的容器。另外上边也提到了这种复制一份新的容器延迟的做法会有数据一致性的问题，如果你对写入的数据读出来实时性很高，那么久不要去选择copyOnWrite容器。 其他文章 copyOnWriteArrayList于同步集合工具容器性能比较：性能比较 简单使用：简单使用 引用说明 1.https://www.cnblogs.com/dolphin0520/p/3938914.html2.《java并发编程实战》]]></content>
  </entry>
  <entry>
    <title><![CDATA[并发编程——线程基础（一）]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[线程是Java学习过程中比较难理解的一part，所以要好好打下基础，之后也会对juc包等其他并发编知识去做一个具体的原理性的学习。 一些概念一、并发与并行 并发：同一个时间间隔内做很多件事情；并行：同一个时刻同时做多件事情。 其实对于这句话可以这样理解：并发是两个任务可以在重叠的时间段内启动、运行和完成。并行是任务在同一时间运行，例如，在多核处理器上，并发是独立执行过程的组合，而并行是同时执行的。并发更像是操作系统用线程模型抽象之后站在线程的角度上看到的任务的”同时“执行。 二、临界区 表示一种公有区域或者公有数据，但是每一次只有一个线程使用，其他线程想使用必须等待。进程在访问资源的时候必须经过这些步骤：【进程】–&gt;【进入区（申请资源）】–&gt;【临界区】–&gt;【退出区（释放资源）】 在进入区中资源如果被占用访问，其他进入阻塞队列等待。 阻塞：一个线程占用了临界区资源，其他需要这个资源的线程在临界区中等待，导致这些线程挂起。 非阻塞：其他线程可以同时进入临界区，但保证公有数据不被改坏。 三、锁 死锁（DeadLock）:线程之间互相等待释放资源 饥饿锁（strarvation）:某一个线程或多个线程无法获取资源，导致一直无法执行 活锁（liveLock）:可以想象为电梯遇到人，同时都往一个方向去给对方让出资源，是个动态的问题 四、并发级别 阻塞状态级别 非阻塞状态级别（这里面还分为三种）(1) 无障碍。一种最弱的非阻塞调度，自由进出临界区。无竞争时要求有限步骤内完成操作；无竞争时直接进行回滚数据。(2) 无锁。保证只有一个线程可以胜出访问临界资源。比如乐观锁（CAS）(3) 无等待的，并发中最高级别，是无锁的，要求所有的线程都在有限步内完成，并且无饥饿的。比如：读线程和写线程，所有线程都是无等待的。比如CopyOnWriteArrayList写时写副本数据，读时共享读，线程之间是无等待的。 五、并行的两个定律 加速比：优化前系统耗时/优化后系统耗时。 说明增加CPU个数不一定增加加速比。 古斯塔夫森定律：只要有足够的并行化，那么加速比和CPU个数成正比 六、线程相关知识线程和进程 进程是分配资源的基本单位，线程是CPU调度的基本单位。进程之间的资源是互相独立不可共享的，但是线程之间是可以共享父线程或者进程的资源的。进程之间切换要比线程之间切换消耗资源代价多很多。 线程的状态 新建状态（NEW）：新创建了一个线程对象 可运行状态（RUNNABLE）：线程对象创建之后，其他线程（比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。 运行（running）：可运行状态的线程获得了cpu时间片，执行程序代码。 阻塞（block）：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行（runnable）状态，才有机会再次获得cpu timeslice转到运行（running）状态。其中阻塞的状态分三种：（1）等待阻塞：运行（running）的线程执行o.wait()方法，JVM会把线程放入到等待队列（waitting queue）中。（2）同步阻塞：运行（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池（lock pool）中。（3）其他阻塞：运行（running）的线程执行Thread.Sleep(long ms)或者join方法，或者发出了IO请求，JVM会把该线程置为阻塞状态。当sleep状态超时、join()等待线程终止或者超时、或者IO处理完毕之后，线程重新转入可运行（runnable）状态。 死亡（dead）：线程run()、main()方法执行结束，或者因一场退出了run()方法，则该线程结束生命周期，死亡的线程不可再次复生。 线程状态扭转的图：可以看到：（1）当调用new Threa()方法之后，线程就会处于新建状态。（2）调用start()方法之后，线程会进入runnable状态，当操作系统选中之后给当前线程分配了时间片线程进入running状态。（3）当run()方法、main()方法结束或者发生异常，线程会进入dead状态。（4）当因为synchronize或者lock同步方法，线程没有获取到锁标识就会进入到锁池（lock pool）中等待；同样当调用o.wait()方法之后线程会进入等待队列中，这时会释放锁或者monitor，直到被其他线程的notify()方法或者notifyAll()方法唤醒。（5）当调用Thread.yield()方法之后，会使线程从running状态转换到runnable状态再去和其他线程一起去竞争时间片资源，所以会出现调用yield()方法之后又重新竞争到了资源变成running状态。（6）当调用了sleep()/join()方法之后，线程并不会释放锁或者monitor，而当sleep时间到了或者调用join()方法的线程执行完毕之后会继续进入running状态。 注意其中线程的一些方法经常在面试中问到的问题： 1.sleep方法和wait方法的区别 （1）sleep是Thread类的方法，wait是Object类的方法（2）调用sleep方法不会释放锁，wait方法会使线程释放当前的锁。（3）wait方法必须别的线程执行notify/notifyAll()方法才能重新获取CPU执行时间。 2.join()方法的本质 join方法是把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如main线程中调用t.join()时候，main线程会获得线程对象t的锁，调用对象的wait方法(等待时间)，直到该对象唤醒main线程，所以意味着main线程调用t.join()时，必须能够拿到线程t对象的锁。注意join()方法也是要捕捉异常的，关于join()方法的比较好的一篇文章：http://uule.iteye.com/blog/1101994 3.yield()方法 yield()方法与sleep()方法类似，只是不能由用户指定暂停多长时间，并且yield()方法只能让同优先级的线程有执行的机会，yield()方法不会释放对象上的锁。 4.wait()和notify()、notifyAll() 这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized中执行使用。synchronized关键字用于保护共享数据，阻止其他线程对共享数据的存取，可以用这三个方法去灵活控制。wait()方法使当前的线程暂停执行并释放对象锁标识，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中，只有锁标志等待池中线程能获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。notifyAll()方法则从对象等待池中移走所有等待那个对象的线程并放入锁标志等待池中。 wait()、notify()方法是Object类的方法，因为他们必须要标识它们操作线程的锁，而锁对象可能是任何对象，所有这里这两个方法是Object类的方法。 线程创建几种方式继承Thread类 可以继承Thread实现其中的run()方法12345678910111213141516171819202122232425262728293031323334353637public class NewThread2 extends Thread &#123; public NewThread2(String name) &#123; super(name); &#125; @Override public void run() &#123; while (!interrupted()) &#123;// 这里的循环是当不被中断的时候 才执行 System.out.println(getName() + &quot; 线程运行&quot;); &#125; &#125; public static void main(String[] args) &#123; NewThread2 t1 = new NewThread2(&quot;first thread&quot;); NewThread2 t2 = new NewThread2(&quot;second thread&quot;); t1.setDaemon(true);// 后台（守护）线程会随着主线程结束也结束 t2.setDaemon(true); t1.start(); t2.start(); // 中断不用stop()方法 已经过时 t1.interrupt(); t2.interrupt();// try &#123; // 让主线程sleep两秒 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实现Runnable接口其实看到Thread类也是实现了Runnable接口的。1234567891011121314151617181920212223242526272829303132333435363738394041424344package newthread;/** * created by zlj on 2018/5/31 * Runnable接口 创建线程 */public class NewThread implements Runnable &#123; @Override public synchronized void run() &#123; while (true) &#123; try &#123; // Thread.sleep(1000);// 调用超时等待使得线程进入阻塞状态 到达时间后线程到达就绪状态 wait();// 线程通讯必须在同步代码块中 否则会报错IllegalMonitorStateException &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;自定义线程执行...&quot;); &#125; &#125; public static void main(String[] args) &#123; NewThread newThread = new NewThread(); // 线程初始化 Thread thread = new Thread(newThread);// 构造函数是runnable接口参数 thread.start();// 调用start方法使得线程进入就绪状态 while (true) &#123; synchronized (newThread) &#123;// 这里同步代码块中监视的是同步的对象 对应上边wait方法获取的是this对象 System.out.println(&quot;主线程执行...&quot;);// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; newThread.notifyAll();// notify方法必须在同步监视器中 否则会报错 &#125; &#125; &#125;&#125; 实现Callable接口（线程可以有返回值和抛出异常）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package newthread;import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;/** * created by zlj on 2018/5/31 * 带有返回值 和 抛出异常 的线程创建 */public class NewThread4 implements Callable&lt;Integer&gt; &#123; // 实现call方法 // callable接口 和 runnable接口 比较：（1）callable接口可以传入泛型有返回值 （2）可以抛出异常 @Override public Integer call() throws Exception &#123; System.out.println(&quot;正在紧张的计算&quot;); // sleep 模拟计算过程 Thread.sleep(3000); return 1; &#125; public static void main(String[] args) &#123; NewThread4 t = new NewThread4(); /* * 对线程任务的封装 */ // 主线程可以先去做点别的 System.out.println(&quot;先去做点别的&quot;); // 首先用FutureTask&lt;T&gt; 对 call 封装成任务 FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(t); // 再根据构造函数去封装成Thread对象 传入FutureTask类型的task Thread thread = new Thread(task); thread.start(); // 拿到线程的结果 try &#123; System.out.println(&quot;计算的结果是&quot; + task.get()); // 这里注意TaskFuture的get()方法是等上边线程结束之后去进行计算结果的。也是一个闭锁操作 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程池实现1234567891011121314151617181920212223242526272829303132package newthread;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * created by zlj on 2018/5/31 * 线程池创建线程 */public class NewThread6 &#123; public static void main(String[] args) &#123; // 创建十个定长的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); // 提交一百个 线程执行的任务 for (int i=0; i&lt;100; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;); &#125; // 线程池的停止销毁 否则程序一直会运行 threadPool.shutdown(); // 注意shutdownNow方法和shutdown方法的区别 threadPool.shutdownNow(); &#125;&#125; Executors中提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。（1）public static ExecutorService newFixedThreadpPool(int nThreads) // 创建国定数目线程的线程池。（2）public static ExecutorService newCachedThreadPool() // 创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有60秒钟未被使用的线程。（3）public static ExecutorService newSingleThreadExecutor（） // 创建一个单线程化的Executor（4）public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) // 创建一个支持定时及周期性的任务执行线程池，多数情况可以用来替代Timer类。但是其实在阿里的代码检查工具中，是不建议去使用这个工具类去调用线程池的，建议去手动的写自定义的线程池。 线程中的其他常见方法 方法 说明 setPriority(int priority) 设置线程的优先级 setDaemon(boolean on) 设置是否为后台线程 interrupt() 中断线程 isAlive() 测试线程是否处于活动状态 守护线程和用户线程的区别：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法允许完毕之后，守护线程也会随着消亡，而用户线程则不依赖会一直运行到完毕为止，在JVM中像垃圾回收线程就是守护线程。但是要注意，设置守护线程要在thread.start()方法之前，否则会报IllegalThreadStateException异常。不应该所有的线程都可以分配给Deamon线程来进行服务，比如读写操作或计算逻辑，因为在Deamon Thread没来得及进行操作时，虚拟机可能已经退出了。 停止线程的方法 使用退出标志，使线程正常退出。 使用stop方法终止线程（已过时不推荐） while判断 + interrupt方法终止线程。其中interrupt方法不会终止正在运行的线程，所以要加入一个判断去完成线程的优雅退出。 一些面试题 线程和进程有什么区别？答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。 Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 线程的sleep()方法和yield()方法有什么区别？答：① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 请说出与线程同步以及线程调度相关的方法。wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 先写到这关于线程的知识总结还有很多，后边关于并发编程还要更深入的理解，这里先上一张知识总结图吧。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式 定义一系列的算法，把每一个算法封装起来，并且使它们可以相互替换。这个模式中使得各个算法可以独立于使用它的客户而变化。 策略模式的构成：1.抽象策略角色：策略类，通常由一个接口或者抽象类实现。2.具体策略角色：包装了相关的算法和行为，实现策略接口或继承抽象类。3.环境角色：context，运行时持有一个策略类的引用，最终给客户端调用。对应的uml图片为： 策略模式让算法独立于使用它的客户而独立变化。策略模式重点是封装不同的算法和行为，不同的场景下可以相互替换。策略模式是开闭原则的体现，开闭原则讲的是一个软件实体应该对拓展开放对修改关闭。因为策略模式在加入新的策略时，不会影响其他类的修改，增加了拓展性，也就是对拓展是开放的；对于调用场景来说，只依赖于抽象，而不依赖于具体实现，所以对修改是关闭的。 策略模式的优点和缺点优点：（1）调用策略中的方法在context中，没有和各个策略的实现耦合在一起，各个实现策略的不同子类可以去拓展、修改和切换。（2）避免写很多if else代码，提高了可观性。同时可以结合抽象类（策略类）去使用，Java支持很好。缺点：（1）客户端调用时必须知道所有的策略类，并且感知到要调用哪一种策略实现。（2）一旦抽象，必然会对一些特殊场景难以处理。并且这里去加入了很多的策略实现类，也有Context类的加入，增加了开销。 代码示例比如现在支付方式有四种，这其中每一种方式都对应着不同的最后费用。这样可以应用策略模式。 Strategy.java12345678910111213package design_pattern.strategy_pattern.intf;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;/** * 抽象策略角色Strategy接口 * @author 夸克 * @create 2018/7/23 17:56 */public interface Strategy &#123; // 定义计算recharge的方法 Double calRecharge(Double charge);&#125; 2.StrategyContext.java123456789101112131415161718192021222324package design_pattern.strategy_pattern.context;import design_pattern.strategy_pattern.factory.StrategyFactory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * 策略模式中的环境角色 context * @author 夸克 * @create 2018/7/24 14:57 */public class Context &#123; private Strategy strategy; public Double calRecharge(Double charge, Integer type) &#123; // 利用一个工厂去生成对应的策略 strategy = StrategyFactory.getInstance().creator(ReChargeTypeEnum.from(type)); if (strategy == null) &#123; throw new RuntimeException(&quot;策略生成错误&quot;); &#125; return strategy.calRecharge(charge); &#125;&#125; 3.策略工厂，返回对应的策略12345678910111213141516171819202122232425262728293031323334353637383940package design_pattern.strategy_pattern.factory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;import design_pattern.strategy_pattern.strategy.BusiAcctStrategy;import design_pattern.strategy_pattern.strategy.CardStrategy;import design_pattern.strategy_pattern.strategy.EBankStrategy;import design_pattern.strategy_pattern.strategy.MobileStrategy;import java.util.HashMap;import java.util.Map;/** * 策略工厂 负责Strategy实例的创建 根据传入的type实现创建不同的策略 * @author 夸克 * @create 2018/7/24 15:01 */public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private static Map&lt;ReChargeTypeEnum, Strategy&gt; map = new HashMap&lt;&gt;(); static &#123; map.put(ReChargeTypeEnum.E_BANK, new EBankStrategy()); map.put(ReChargeTypeEnum.BUSI_ACCOUNTS, new BusiAcctStrategy()); map.put(ReChargeTypeEnum.MOBILE, new MobileStrategy()); map.put(ReChargeTypeEnum.CARD_RECHARGE, new CardStrategy()); &#125; /** * getInstance方法进行初始化 * @return */ public static StrategyFactory getInstance() &#123; return factory; &#125; public Strategy creator(ReChargeTypeEnum type) &#123; return map.get(type); &#125;&#125; 四种策略的实现：12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:53 */public class BusiAcctStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.9; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:57 */public class CardStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge + charge * 0.01; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:52 */public class EBankStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.85; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:54 */public class MobileStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge; &#125;&#125; Main.java12345678910111213141516171819202122232425package design_pattern.strategy_pattern.main;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.context.Context;/** * @author 夸克 * @create 2018/7/26 23:30 */public class StrategyMain &#123; public static void main(String[] args) &#123; Context context = new Context(); /** * 计算四种计算方式 */ Double aDouble = context.calRecharge(100D, ReChargeTypeEnum.E_BANK.getValue()); Double bDouble = context.calRecharge(100D, ReChargeTypeEnum.BUSI_ACCOUNTS.getValue()); Double cDouble = context.calRecharge(100D, ReChargeTypeEnum.MOBILE.getValue()); Double dDouble = context.calRecharge(100D, ReChargeTypeEnum.CARD_RECHARGE.getValue()); System.out.println(aDouble + &quot;\t&quot; + bDouble + &quot;\t&quot; + cDouble + &quot;\t&quot; + dDouble); &#125;&#125; github代码已经上传至我的github：https://github.com/zhanglijun1217/java8/tree/master/src/design_pattern/strategy_pattern 引用https://www.jianshu.com/p/71feb016ac05]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[orika转换bean的字段丢失]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2Forika%E8%BD%AC%E6%8D%A2bean%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%A2%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[背景 用orika对象转换工具去转换list的时候，发现只去完整转了list的第一条数据，但是后边的数据都没有将字段全部映射上去。 描述： 1.debug时发现的，源数据list是数据都存在的 2.转完之后的list数据，发现userName、realName等字段是丢失的。 解决经过排查发现是因为在转换注册的字段中，有个type字段没有对应的注册上去。这里就造成了orika这个转换工具丢失了list中记录字段的数据转换。 这里去记录一下这次碰到的小bug，其实也是粗心导致的。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>orika</tag>
        <tag>bug</tag>
      </tags>
  </entry>
</search>
